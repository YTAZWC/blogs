const t='{"documentCount":65,"nextId":65,"documentIds":{"0":"/article/wlhley8t/#画类图","1":"/dubbo/grgvjnyc/#项目架构目标","2":"/dubbo/grgvjnyc/#集群和分布式","3":"/java-concurrent/#学习视频","4":"/dubbo/grgvjnyc/#架构演进","5":"/java-concurrent/#juc是什么","6":"/mysql-learn/#学习书籍","7":"/zookeeper/wz9jt6uj/#概述","8":"/dubbo/grgvjnyc/#单体结构","9":"/java-concurrent/#前置知识","10":"/zookeeper/wz9jt6uj/#工作机制","11":"/dubbo/grgvjnyc/#垂直架构","12":"/learn/#介绍","13":"/zookeeper/wz9jt6uj/#应用场景","14":"/dubbo/grgvjnyc/#分布式架构","15":"/design-pattern/#学习视频","16":"/design-pattern/biychupa/#设计模式的重要性","17":"/zookeeper/wz9jt6uj/#统一命名服务","18":"/article/adrm6moe/#简介","19":"/dubbo/grgvjnyc/#soa架构","20":"/design-pattern/#学习书籍","21":"/design-pattern/htacao8y/#基本介绍","22":"/design-pattern/biychupa/#设计模式在软件中哪里","23":"/zookeeper/wz9jt6uj/#统一配置管理","24":"/design-pattern/06w076lh/#基本介绍","25":"/article/adrm6moe/#并行流和串行流","26":"/dubbo/grgvjnyc/#微服务架构","27":"/design-pattern/htacao8y/#应用实例","28":"/design-pattern/nu3k3c27/#基本介绍","29":"/design-pattern/biychupa/#设计模式的目的","30":"/design-pattern/06w076lh/#应用实例","31":"/article/adrm6moe/#lambda-表达式","32":"/design-pattern/vys0x21y/#oo-面向对象-中继承的思考和说明","33":"/test-quality/8byrze87/#为什么需要软件测试-核心价值","34":"/design-pattern/htacao8y/#方案1","35":"/design-pattern/nu3k3c27/#应用实例","36":"/design-pattern/biychupa/#设计模式常用七大原则","37":"/article/adrm6moe/#举例","38":"/design-pattern/vys0x21y/#基本介绍","39":"/test-quality/8byrze87/#哪些人需要了解软件测试","40":"/design-pattern/htacao8y/#方案2","41":"/design-pattern/nu3k3c27/#方案-1","42":"/article/adrm6moe/#基本使用","43":"/design-pattern/vys0x21y/#实例","44":"/test-quality/8byrze87/#软件测试等级划分","45":"/design-pattern/htacao8y/#方案3","46":"/design-pattern/nu3k3c27/#方案-2","47":"/article/adrm6moe/#总结","48":"/design-pattern/vys0x21y/#错误示例","49":"/test-quality/8byrze87/#第1级-初始阶段","50":"/design-pattern/htacao8y/#注意事项和细节","51":"/design-pattern/nu3k3c27/#依赖关系传递的三种方式","52":"/article/adrm6moe/#函数式-functional-接口","53":"/test-quality/8byrze87/#第2级-定义阶段","54":"/design-pattern/nu3k3c27/#接口传递","55":"/article/adrm6moe/#java内置函数式接口","56":"/test-quality/8byrze87/#第3级-集成阶段","57":"/design-pattern/nu3k3c27/#构造方法传递","58":"/article/adrm6moe/#方法引用和构造器引用","59":"/test-quality/8byrze87/#第4级-管理与测量","60":"/design-pattern/nu3k3c27/#setter-方式传递","61":"/article/adrm6moe/#stream-api","62":"/test-quality/8byrze87/#第5级-最佳化","63":"/design-pattern/nu3k3c27/#注意事项和细节","64":"/article/adrm6moe/#optional类"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,17],"2":[1,1,15],"3":[1,1,2],"4":[1,1,1],"5":[1,1,5],"6":[1,1,2],"7":[1,1,3],"8":[1,2,11],"9":[1,1,8],"10":[1,2,1],"11":[1,2,8],"12":[1,1,2],"13":[1,2,2],"14":[1,2,20],"15":[1,1,3],"16":[1,1,16],"17":[1,3,8],"18":[1,1,17],"19":[1,2,25],"20":[1,1,1],"21":[1,1,9],"22":[2,1,11],"23":[1,3,13],"24":[1,1,3],"25":[1,2,7],"26":[1,2,34],"27":[1,1,2],"28":[1,1,30],"29":[1,1,40],"30":[1,1,90],"31":[2,1,7],"32":[3,1,21],"33":[3,1,7],"34":[1,2,50],"35":[1,1,3],"36":[2,1,10],"37":[1,3,42],"38":[1,1,31],"39":[2,1,5],"40":[1,2,58],"41":[2,2,68],"42":[1,3,96],"43":[1,1,1],"44":[1,1,1],"45":[1,2,57],"46":[2,2,60],"47":[1,3,14],"48":[1,2,74],"49":[2,2,12],"50":[1,1,12],"51":[1,1,1],"52":[3,1,110],"53":[2,2,16],"54":[1,2,47],"55":[1,4,33],"56":[2,2,14],"57":[1,2,43],"58":[1,1,1],"59":[2,2,12],"60":[2,2,44],"61":[2,1,1],"62":[2,2,10],"63":[1,1,10],"64":[1,1,1]},"averageFieldLength":[1.2923076923076924,1.5384615384615385,21.215384615384615],"storedFields":{"0":{"title":"画类图","titles":[null]},"1":{"title":"项目架构目标","titles":[null]},"2":{"title":"集群和分布式","titles":[null]},"3":{"title":"学习视频","titles":[null]},"4":{"title":"架构演进","titles":[null]},"5":{"title":"JUC是什么","titles":[null]},"6":{"title":"学习书籍","titles":[null]},"7":{"title":"概述","titles":[null]},"8":{"title":"单体结构","titles":[null,"架构演进"]},"9":{"title":"前置知识","titles":[null]},"10":{"title":"工作机制","titles":[null,"概述"]},"11":{"title":"垂直架构","titles":[null,"架构演进"]},"12":{"title":"介绍","titles":[null]},"13":{"title":"应用场景","titles":[null,"概述"]},"14":{"title":"分布式架构","titles":[null,"架构演进"]},"15":{"title":"学习视频","titles":[null]},"16":{"title":"设计模式的重要性","titles":[null]},"17":{"title":"统一命名服务","titles":[null,"概述","应用场景"]},"18":{"title":"简介","titles":[null]},"19":{"title":"SOA架构","titles":[null,"架构演进"]},"20":{"title":"学习书籍","titles":[null]},"21":{"title":"基本介绍","titles":[null]},"22":{"title":"设计模式在软件中哪里?","titles":[null]},"23":{"title":"统一配置管理","titles":[null,"概述","应用场景"]},"24":{"title":"基本介绍","titles":[null]},"25":{"title":"并行流和串行流","titles":[null,"简介"]},"26":{"title":"微服务架构","titles":[null,"架构演进"]},"27":{"title":"应用实例","titles":[null]},"28":{"title":"基本介绍","titles":[null]},"29":{"title":"设计模式的目的","titles":[null]},"30":{"title":"应用实例","titles":[null]},"31":{"title":"Lambda 表达式","titles":[null]},"32":{"title":"OO(面向对象) 中继承的思考和说明","titles":[null]},"33":{"title":"为什么需要软件测试(核心价值)?","titles":[null]},"34":{"title":"方案1","titles":[null,"应用实例"]},"35":{"title":"应用实例","titles":[null]},"36":{"title":"设计模式常用七大原则:","titles":[null]},"37":{"title":"举例","titles":[null,"Lambda 表达式"]},"38":{"title":"基本介绍","titles":[null]},"39":{"title":"哪些人需要了解软件测试?","titles":[null]},"40":{"title":"方案2","titles":[null,"应用实例"]},"41":{"title":"方案 1","titles":[null,"应用实例"]},"42":{"title":"基本使用","titles":[null,"Lambda 表达式"]},"43":{"title":"实例","titles":[null]},"44":{"title":"软件测试等级划分","titles":[null]},"45":{"title":"方案3","titles":[null,"应用实例"]},"46":{"title":"方案 2","titles":[null,"应用实例"]},"47":{"title":"总结","titles":[null,"Lambda 表达式"]},"48":{"title":"错误示例","titles":[null,"实例"]},"49":{"title":"第1级. 初始阶段","titles":[null,"软件测试等级划分"]},"50":{"title":"注意事项和细节","titles":[null]},"51":{"title":"依赖关系传递的三种方式","titles":[null]},"52":{"title":"函数式(Functional)接口","titles":[null]},"53":{"title":"第2级. 定义阶段","titles":[null,"软件测试等级划分"]},"54":{"title":"接口传递","titles":[null,"依赖关系传递的三种方式"]},"55":{"title":"Java内置函数式接口","titles":[null,"函数式(Functional)接口"]},"56":{"title":"第3级. 集成阶段","titles":[null,"软件测试等级划分"]},"57":{"title":"构造方法传递","titles":[null,"依赖关系传递的三种方式"]},"58":{"title":"方法引用和构造器引用","titles":[null]},"59":{"title":"第4级. 管理与测量","titles":[null,"软件测试等级划分"]},"60":{"title":"setter 方式传递","titles":[null,"依赖关系传递的三种方式"]},"61":{"title":"Stream API","titles":[null]},"62":{"title":"第5级. 最佳化","titles":[null,"软件测试等级划分"]},"63":{"title":"注意事项和细节","titles":[null]},"64":{"title":"Optional类","titles":[null]}},"dirtCount":0,"index":[["利于层序扩展和优化",{"2":{"63":1}}],["变量的声明类型尽量是抽象类或接口",{"2":{"63":1}}],["底层模块尽量都要有抽象类或接口",{"2":{"63":1}}],["不断改进测试",{"2":{"62":1}}],["不用多次编写",{"2":{"29":1}}],["机制好转",{"2":{"62":1}}],["自动工具完全支持测试用例的运行",{"2":{"62":1}}],["自动化部署",{"2":{"26":1}}],["建立缺陷预防的思想",{"2":{"62":1}}],["出现质量管理活动",{"2":{"59":1}}],["拥有流程控制",{"2":{"59":1}}],["拥有基本的测试工具",{"2":{"56":1}}],["管理与测量",{"0":{"59":1}}],["构造器",{"2":{"57":1}}],["构造方法传递",{"0":{"57":1}}],["成员",{"2":{"57":1}}],["成立专门的测试组织",{"2":{"56":1}}],["没有开展评审活动",{"2":{"56":1}}],["基于规范的测试",{"2":{"59":1}}],["基于技术的测试",{"2":{"56":1}}],["基本使用",{"0":{"42":1}}],["基本介绍",{"0":{"21":1,"24":1,"28":1,"38":1}}],["集成阶段",{"0":{"56":1}}],["集群",{"2":{"2":1}}],["集群和分布式",{"0":{"2":1}}],["确定类型为t的对象是否满足某约束",{"2":{"55":1}}],["确保产品的质量",{"2":{"33":1}}],["断定型接口",{"2":{"55":1}}],["结果是r类型的对象",{"2":{"55":1}}],["供给型接口",{"2":{"55":1}}],["供其他调用者消费",{"2":{"14":1}}],["包含方法",{"2":{"55":4}}],["包含的功能如",{"2":{"19":1}}],["消费型接口",{"2":{"55":1}}],["用途",{"2":{"55":1}}],["用户无法接受",{"2":{"49":1}}],["用户",{"2":{"39":1}}],["返回类型为t的对象",{"2":{"55":1}}],["返回类型",{"2":{"55":1}}],["返回两个数的差",{"2":{"48":1}}],["参数类型",{"2":{"55":1}}],["参数的小括号可以省略",{"2":{"42":1}}],["打开",{"2":{"54":1,"57":1,"60":1}}],["长虹电视机",{"2":{"54":1,"57":1,"60":1}}],["\\tprivate",{"2":{"60":1}}],["\\tpublic",{"2":{"54":2,"57":2,"60":7}}],["\\t",{"2":{"54":3,"57":3,"60":5}}],["\\t\\tthis",{"2":{"60":2}}],["\\t\\tsystem",{"2":{"54":1,"57":1,"60":1}}],["\\t\\t",{"2":{"54":1,"57":1,"60":1}}],["\\t\\topenandclose",{"2":{"54":2,"57":2,"60":3}}],["\\t\\tchanghong",{"2":{"54":1,"57":1,"60":1}}],["产品存在质量问题",{"2":{"53":1}}],["从而导致大量缺陷扩散到代码中",{"2":{"53":1}}],["从上到下运行程序",{"2":{"25":1}}],["取得了一定的效果",{"2":{"53":1}}],["第5级",{"0":{"62":1}}],["第4级",{"0":{"59":1}}],["第3级",{"0":{"56":1}}],["第2级",{"0":{"53":1}}],["第1级",{"0":{"49":1}}],["匿名实现类表示的现在都可以用lambda表达式来写",{"2":{"52":1}}],["它们必须依附于一类特别的对象类型",{"2":{"52":1}}],["它将应用程序的不同功能单元",{"2":{"19":1}}],["函数型接口",{"2":{"55":1}}],["函数被当做一等公民对待",{"2":{"52":1}}],["函数式接口",{"2":{"52":1,"55":1}}],["函数式",{"0":{"52":1},"1":{"55":1}}],["那么该对象就可以用lambda表达式来表示",{"2":{"52":1}}],["那么该异常需要在目标接口的抽象方法上进行声明",{"2":{"52":1}}],["那么类型",{"2":{"38":1}}],["非运行时异常",{"2":{"52":1}}],["非常方便",{"2":{"29":1}}],["然后接口中只有一个抽象方法",{"2":{"52":1}}],["used",{"2":{"52":1}}],["util",{"2":{"5":1}}],["标记接口为函数式接口",{"2":{"52":1}}],["点开查看示例",{"2":{"52":1}}],["点击查看代码",{"2":{"54":1,"57":1,"60":1}}],["点击查看java中函数式接口注解的底层实现",{"2":{"52":1}}],["点击查看",{"2":{"30":1}}],["才可以在方法级保持单一职责原则",{"2":{"50":1}}],["才能在代码级违反单一职责原则",{"2":{"50":1}}],["只能被动地找缺陷",{"2":{"59":1}}],["只要一个对象是函数式接口的实例",{"2":{"52":1}}],["只包含一个抽象方法的接口",{"2":{"52":1}}],["只有当编码完成后才开始测试",{"2":{"53":1}}],["只有类中方法数量足够少",{"2":{"50":1}}],["只有逻辑足够简单",{"2":{"50":1}}],["只是增加方法",{"2":{"45":1}}],["通过统计抽样等方式不断改进测试",{"2":{"62":1}}],["通过setter方法传递",{"2":{"60":1}}],["通过setter方法进行依赖传递",{"2":{"60":1}}],["通过构造方法依赖传递",{"2":{"57":1}}],["通过构造器进行依赖传递",{"2":{"57":1}}],["通过接口传递实现依赖",{"2":{"54":1}}],["通过硬件增加",{"2":{"1":1}}],["通常情况下",{"2":{"50":1}}],["降低变更引起的风险",{"2":{"50":1}}],["降低类的复杂性",{"2":{"50":1}}],["降低处理能力",{"2":{"1":1}}],["注意事项和细节",{"0":{"50":1,"63":1}}],["存在很多缺陷",{"2":{"49":1}}],["存在的问题",{"2":{"11":1,"14":1}}],["弊端",{"2":{"49":1,"53":1,"56":1,"59":1}}],["最佳化",{"0":{"62":1}}],["最省力气",{"2":{"49":1}}],["最大化减少空指针异常",{"2":{"18":1}}],["优势",{"2":{"49":1,"53":1,"56":1,"59":1,"62":1}}],["优点",{"2":{"8":1}}],["目标是表明软件符合其技术规范",{"2":{"53":1}}],["目标是表明软件是奏效的",{"2":{"49":1}}],["目前程序员门槛越来越高",{"2":{"16":1}}],["措施",{"2":{"49":1,"53":1,"56":1,"59":1,"62":1}}],["初始阶段",{"0":{"49":1}}],["7",{"2":{"48":1}}],["9",{"2":{"48":2}}],["与",{"2":{"48":1}}],["与大括号若有",{"2":{"42":1}}],["新增了一个方法func2",{"2":{"48":1}}],["function",{"2":{"55":1}}],["functionalinterface注解来检验是否为函数式接口",{"2":{"52":1}}],["functionalinterface",{"2":{"52":3}}],["functional",{"0":{"52":1},"1":{"55":1}}],["func2",{"2":{"48":2}}],["func1的值",{"2":{"48":1}}],["func1",{"2":{"48":7}}],["8",{"2":{"48":3}}],["8=9",{"2":{"48":1}}],["8=",{"2":{"48":3}}],["80",{"2":{"26":2}}],["07",{"2":{"48":1}}],["09",{"2":{"46":1}}],["lt",{"2":{"55":4}}],["lang",{"2":{"52":4}}],["lambda体应该使用一对阔话包裹",{"2":{"47":1}}],["lambda体",{"2":{"42":1}}],["lambda形参列表的参数类型可以省略",{"2":{"47":1}}],["lambda形参列表",{"2":{"42":1}}],["lambda操作符",{"2":{"42":1}}],["lambda",{"0":{"31":1},"1":{"37":1,"42":1,"47":1},"2":{"42":4,"52":1}}],["lambda表达式就是一个函数式接口的实例",{"2":{"52":1}}],["lambda表达式是对象",{"2":{"52":1}}],["lambda表达式的类型是函数",{"2":{"52":1}}],["lambda表达式的本质",{"2":{"47":1}}],["lambda表达式的本质就是",{"2":{"42":3}}],["lambda表达式的本质是什么呢",{"2":{"42":3}}],["lambda表达式",{"2":{"18":1,"37":2,"42":6}}],["liskov1",{"2":{"48":2}}],["liskov",{"2":{"48":2}}],["错误示例",{"0":{"48":1}}],["更准确的来说是作为函数式接口的实例",{"2":{"47":1}}],["和return",{"2":{"47":1}}],["总结",{"0":{"47":1}}],["微信信息",{"2":{"46":2}}],["微信",{"2":{"46":1}}],["微服务架构强调的一个重点是",{"2":{"26":1}}],["微服务架构是在",{"2":{"26":1}}],["微服务架构",{"0":{"26":1},"2":{"26":1}}],["电子邮件",{"2":{"46":1}}],["电子邮件信息",{"2":{"41":2,"46":2}}],["定义阶段",{"0":{"53":1}}],["定义接口",{"2":{"46":1}}],["定义的所有程序",{"2":{"38":1}}],["客户端无需改变",{"2":{"46":1}}],["客户端不应该依赖它不需要的接口",{"2":{"24":1}}],["仍然遵守单一职责原则",{"2":{"45":1}}],["虽然没有在",{"2":{"45":1}}],["虽然不强制子类遵守",{"2":{"32":1}}],["考虑在交通工具类中",{"2":{"45":1}}],["还需要修改客户端",{"2":{"45":1}}],["还可能有微信",{"2":{"41":1}}],["体只有一条语句时",{"2":{"42":1}}],["多条执行语句",{"2":{"42":1}}],["若",{"2":{"52":1}}],["若只需要一个参数时",{"2":{"42":1}}],["若对类图理解不够清楚",{"2":{"30":1}}],["称为函数式接口",{"2":{"52":1}}],["称为",{"2":{"42":1}}],["称为服务",{"2":{"19":1}}],["因为可由编译器推断得出",{"2":{"42":1}}],["因此按照接口隔离原则来进行分析",{"2":{"30":1}}],["数据类型可以省略",{"2":{"42":1}}],["作为接口的实例",{"2":{"42":3}}],["作为独立的服务",{"2":{"14":1}}],["需要两个或以上的参数",{"2":{"42":1}}],["需要一个参数",{"2":{"42":1}}],["需要考虑所有的子类",{"2":{"32":1}}],["格式六",{"2":{"42":1}}],["格式五",{"2":{"42":1}}],["格式四",{"2":{"42":1}}],["格式三",{"2":{"42":1}}],["格式二",{"2":{"42":1}}],["格式一",{"2":{"42":1}}],["无法主动控制缺陷",{"2":{"59":1}}],["无",{"2":{"55":1}}],["无意",{"2":{"48":1}}],["无返回值",{"2":{"42":1}}],["无参",{"2":{"42":1}}],["六种情况",{"2":{"42":1}}],["右边",{"2":{"42":1,"47":1}}],["左边",{"2":{"42":1,"47":1}}],["箭头操作符",{"2":{"42":1}}],["或者两者都有",{"2":{"63":1}}],["或",{"2":{"42":1}}],["符号含义",{"2":{"42":1}}],["表示接收者",{"2":{"41":1}}],["表达式抛出一个受检异常",{"2":{"52":1}}],["表达式",{"0":{"31":1},"1":{"37":1,"42":1,"47":1}}],["引入一个抽象的接口",{"2":{"41":1}}],["引擎",{"2":{"18":1}}],["得到解决思路",{"2":{"41":1}}],["短信等",{"2":{"41":2}}],["我们可以使用lambda表达式创建函数式接口的对象",{"2":{"52":1}}],["我们可以自定义函数式接口",{"2":{"52":1}}],["我们应当遵守单一职责原则",{"2":{"50":1}}],["我们获取消息的对象不只是电子邮件",{"2":{"41":1}}],["我爱北京故宫",{"2":{"37":1,"42":1}}],["我爱北京天安门",{"2":{"37":1,"42":1}}],["且比较容易想到",{"2":{"41":1}}],["完成person接收消息的功能",{"2":{"41":1,"46":1}}],["get",{"2":{"55":1}}],["getinfo",{"2":{"41":2,"46":4}}],["generated",{"2":{"54":1}}],["general",{"2":{"52":1}}],["gt",{"2":{"22":3,"42":1,"47":2,"55":4}}],["53",{"2":{"45":1}}],["56",{"2":{"41":1}}],["5方法",{"2":{"30":2}}],["采用的是直接实现方式",{"2":{"41":1}}],["见方案3",{"2":{"40":1}}],["改动过大",{"2":{"45":1}}],["改动的代码会比较少",{"2":{"40":1}}],["改进",{"2":{"40":1}}],["直接修改vehicle类",{"2":{"40":1}}],["同时也需要修改客户端",{"2":{"40":1}}],["同时类图的具体实现代码如下所示",{"2":{"30":1}}],["遵守单一职责原则",{"2":{"40":1}}],["遵循里氏替换原则",{"2":{"38":1,"63":1}}],["水路运行",{"2":{"40":1}}],["天空运行",{"2":{"40":2}}],["公路运行",{"2":{"40":3}}],["whatsoever",{"2":{"52":1}}],["when",{"2":{"52":1}}],["weixin",{"2":{"41":1,"46":2}}],["webservice",{"2":{"14":1}}],["world",{"2":{"41":2,"46":4}}],["watervehicle",{"2":{"40":4}}],["根据依赖倒转原则",{"2":{"46":1}}],["根据方案2中",{"2":{"45":1}}],["根据方案1",{"2":{"40":1}}],["根据不同的交通工具",{"2":{"34":1}}],["哪些人需要了解软件测试",{"0":{"39":1}}],["组合",{"2":{"38":1}}],["时",{"2":{"38":1}}],["都可以省略",{"2":{"42":1}}],["都代换成",{"2":{"38":1}}],["都有类型为",{"2":{"38":1}}],["3",{"2":{"48":4}}],["3=14",{"2":{"48":1}}],["3=8",{"2":{"48":1}}],["3=",{"2":{"48":2}}],["32",{"2":{"37":1,"42":1}}],["3方法",{"2":{"30":2}}],["x3c",{"2":{"37":4,"42":12,"52":7}}],[">",{"2":{"37":2,"42":9}}],["由匿名内部类转换到lambda表达式",{"2":{"37":1}}],["由上述类图结合具体实现代码中",{"2":{"30":1}}],["举例",{"0":{"37":1}}],["合成复用原则",{"2":{"36":1}}],["迪米特原则",{"2":{"36":1}}],["开展各种与测试有关的度量活动",{"2":{"62":1}}],["开始考虑客户和用户的需求来建立测试目标",{"2":{"56":1}}],["开关的接口",{"2":{"54":1}}],["开闭原则ocp",{"2":{"36":1}}],["开发过程引入评审机制",{"2":{"59":1}}],["开发出的软件产品仍然会存在较多缺陷",{"2":{"53":1}}],["开发出的软件产品得不到任何质量的保证",{"2":{"49":1}}],["开发者可以自由选择开发技术",{"2":{"26":1}}],["开发工具与jvm带来了大量新特性",{"2":{"18":1}}],["开发部署方便",{"2":{"8":1}}],["里氏代换原则",{"2":{"36":1}}],["里氏替换原则说明",{"2":{"38":1}}],["里氏替换原则",{"2":{"32":1}}],["单一职责原则",{"2":{"36":1}}],["单体结构",{"0":{"8":1}}],["详见方案2",{"2":{"34":1}}],["详情",{"2":{"30":1}}],["解决问题",{"2":{"38":1}}],["解决办法",{"2":{"34":1}}],["解决了什么问题",{"2":{"16":1}}],["又负责飞机的运行等",{"2":{"34":1}}],["显然违反了单一职责原则",{"2":{"34":1}}],["轮船",{"2":{"34":1,"40":2,"45":2}}],["交通工具类",{"2":{"34":1}}],["飞机",{"2":{"34":2,"40":2,"45":2}}],["汽车",{"2":{"34":1,"45":2}}],["摩托车",{"2":{"34":2,"40":2}}],["vehicle2",{"2":{"45":7}}],["vehicle",{"2":{"34":9,"40":6,"45":6}}],["void",{"2":{"30":39,"34":2,"37":3,"40":4,"41":2,"42":8,"45":4,"46":2,"48":1,"52":2,"54":5,"55":2,"57":5,"60":7}}],["来代表交通工具",{"2":{"34":1}}],["方法引用和构造器引用",{"0":{"58":1}}],["方法引用的写法",{"2":{"37":1}}],["方式传递",{"0":{"60":1}}],["方式6",{"2":{"42":1}}],["方式5",{"2":{"42":1}}],["方式4",{"2":{"42":1}}],["方式3",{"2":{"42":1,"60":1}}],["方式2",{"2":{"42":1,"57":1}}],["方式1完成",{"2":{"46":1}}],["方式1",{"2":{"42":1,"54":1}}],["方案3分析",{"2":{"45":1}}],["方案3",{"0":{"45":1},"2":{"45":1}}],["方案",{"0":{"41":1,"46":1}}],["方案2分析",{"2":{"40":1}}],["方案2",{"0":{"40":1},"2":{"40":1,"46":1}}],["方案1",{"0":{"34":1},"2":{"34":1,"41":1}}],["方便自动化部署",{"2":{"26":1}}],["效果更好",{"2":{"33":1,"56":1}}],["效率更高",{"2":{"33":1}}],["核心价值",{"0":{"33":1}}],["便是解决编程中",{"2":{"32":1}}],["便于其他程序员阅读和理解",{"2":{"29":1}}],["便于并行",{"2":{"18":1}}],["便于识别",{"2":{"17":1}}],["涉及到子类的功能也有可能会出现故障",{"2":{"32":1}}],["则对应的",{"2":{"41":1}}],["则当这个类需要修改时",{"2":{"32":1}}],["则会对client发出通知",{"2":{"23":1}}],["增加对象间的耦合性",{"2":{"32":1}}],["程序稳定性更好",{"2":{"63":1}}],["程序员",{"2":{"39":1}}],["程序员面临着来自",{"2":{"29":1}}],["程序",{"2":{"38":1}}],["程序的可移植性降低",{"2":{"32":1}}],["也就是说",{"2":{"52":1}}],["也即",{"2":{"52":1}}],["也带来了弊端",{"2":{"32":1}}],["也不需要协调其他团队",{"2":{"26":1}}],["继承时",{"2":{"63":1}}],["继承实际上让两个类的耦合性增加了",{"2":{"38":1}}],["继承给程序设计带来遍历的同时",{"2":{"32":1}}],["继承隐含的含义",{"2":{"32":1}}],["父类已经实现好的方法",{"2":{"32":1}}],["本质",{"2":{"31":1}}],["nums2",{"2":{"48":6}}],["nums1",{"2":{"48":6}}],["new",{"2":{"30":8,"34":1,"37":2,"40":3,"41":2,"42":3,"45":1,"46":3,"48":2,"54":2,"57":2,"60":2}}],["nashorn",{"2":{"18":1}}],["11+3+9=23",{"2":{"48":1}}],["11+3+9=",{"2":{"48":1}}],["11",{"2":{"48":8}}],["17",{"2":{"46":1}}],["1",{"0":{"41":1},"2":{"46":1,"48":7}}],["12",{"2":{"37":1,"42":1}}],["18",{"2":{"30":1}}],["15",{"2":{"30":1,"34":1,"40":1,"45":1}}],["16",{"2":{"30":1,"41":2,"46":1,"48":1}}],["100",{"2":{"26":1}}],["t",{"2":{"55":15}}],["tv",{"2":{"54":3,"57":5,"60":6}}],["type",{"2":{"52":1}}],["target",{"2":{"52":1}}],["take",{"2":{"52":1}}],["this",{"2":{"57":2}}],["that",{"2":{"52":2}}],["the",{"2":{"52":4}}],["thread",{"2":{"52":4}}],["t2",{"2":{"38":2}}],["t1",{"2":{"38":3}}],["test6",{"2":{"42":1}}],["test5",{"2":{"42":1}}],["test4",{"2":{"42":1}}],["test3",{"2":{"42":1}}],["test2",{"2":{"37":1,"42":1}}],["test1",{"2":{"37":1,"42":1}}],["test",{"2":{"37":2,"42":6,"55":1}}],["to",{"2":{"52":2}}],["todo",{"2":{"30":1,"48":1,"54":1}}],["top",{"2":{"30":3,"34":1,"40":1,"41":2,"45":1,"46":2,"48":2}}],["title",{"2":{"30":1,"41":1,"46":1,"48":1}}],["花木凋零成兰",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1}}],["输出结果",{"2":{"30":1,"41":1,"46":1}}],["具体示例如下",{"2":{"52":1}}],["具体实现代码和结果如下所示",{"2":{"48":1}}],["具体代码",{"2":{"30":1,"41":1,"46":1,"48":1}}],["具有更好的",{"2":{"29":1}}],["保证类a的依赖最小接口",{"2":{"30":1}}],["这样在变量引用和实际对象间",{"2":{"63":1}}],["这就是lambda表达式和函数式接口的关系",{"2":{"52":1}}],["这里本意是求出",{"2":{"48":1}}],["这种修改方法没有对原来的类做大的修改",{"2":{"45":1}}],["这是很没有必要的",{"2":{"30":1}}],["这些类实现",{"2":{"41":1}}],["这些小应用之间通过服务完成交互和集成",{"2":{"26":1}}],["这些事组合成一件事",{"2":{"2":1}}],["但是在java8中",{"2":{"52":1}}],["但是在方法级别上",{"2":{"45":1}}],["但是随着python",{"2":{"52":1}}],["但是没有返回值",{"2":{"42":1}}],["但是",{"2":{"41":1}}],["但是改动过大",{"2":{"40":1}}],["但是子类对父类已实现方法随机修改的话",{"2":{"32":1}}],["但是类b必须实现interface1中的所有方法",{"2":{"30":1}}],["但是类a只会使用到interface1中的三个方法",{"2":{"30":1}}],["但是指挥用到1",{"2":{"30":4}}],["43",{"2":{"42":2}}],["47",{"2":{"40":1}}],["44",{"2":{"34":1}}],["4",{"2":{"30":3,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1}}],["20",{"2":{"48":1}}],["2024",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1}}],["21",{"2":{"37":4,"42":2}}],["22",{"2":{"34":1,"40":1,"42":2,"45":1}}],["2",{"0":{"46":1},"2":{"30":2}}],["依赖关系传递的三种方式",{"0":{"51":1},"1":{"54":1,"57":1,"60":1}}],["依赖",{"2":{"30":4,"38":1}}],["依赖倒转",{"2":{"28":1,"36":1}}],["依赖倒转原则的设计理念",{"2":{"28":1}}],["依赖倒转原则",{"2":{"28":1}}],["类级别上遵守单一职责原则",{"2":{"45":1}}],["类型推断",{"2":{"42":1,"47":1}}],["类依赖接口",{"2":{"41":1}}],["类也需要增加对应的接收方法",{"2":{"41":1}}],["类接收消息的功能",{"2":{"35":1}}],["类a通过接口interface1依赖使用类b",{"2":{"30":1}}],["类通过接口interface1",{"2":{"30":4}}],["类库",{"2":{"18":1}}],["实现接口",{"2":{"54":1,"60":1}}],["实现三个对应不同交通工具的方法",{"2":{"45":1}}],["实现代码及输出结果如下所示",{"2":{"41":1,"46":1}}],["实现了",{"2":{"30":22}}],["实例",{"0":{"43":1},"1":{"48":1}}],["实例2",{"2":{"37":1}}],["实例1",{"2":{"37":1}}],["实际上是在设定规范和契约",{"2":{"32":1}}],["实际项目中使用过什么设计模式",{"2":{"16":1}}],["boolean",{"2":{"55":2}}],["be",{"2":{"52":1}}],["b类继承了a",{"2":{"48":1}}],["b类",{"2":{"30":2}}],["b",{"2":{"30":16,"48":7}}],["bus",{"2":{"19":1}}],["ytazwc",{"2":{"30":3,"34":1,"40":1,"41":2,"45":1,"46":2,"48":2}}],["predicate",{"2":{"55":1}}],["println",{"2":{"30":16,"34":1,"37":7,"40":3,"41":1,"42":22,"45":3,"46":1,"48":6,"54":1,"57":1,"60":1}}],["principle",{"2":{"28":1,"30":3,"34":1,"40":1,"41":2,"45":1,"46":2,"48":2}}],["play",{"2":{"54":3,"57":3,"60":3}}],["p>",{"2":{"52":1}}],["p",{"2":{"38":2}}],["person",{"2":{"35":1,"41":7,"46":6}}],["public",{"2":{"30":31,"34":3,"37":4,"40":5,"41":4,"42":9,"45":5,"46":6,"48":5,"52":4,"54":4,"57":6,"60":1}}],["package",{"2":{"30":3,"34":1,"40":1,"41":2,"45":1,"46":2,"48":2,"52":2}}],["首先查看下面的uml类图",{"2":{"30":1}}],["就存在一个缓冲层",{"2":{"63":1}}],["就是接口的实例",{"2":{"31":1}}],["就是一个线程上",{"2":{"25":1}}],["就曾经说过",{"2":{"29":1}}],["changhong",{"2":{"54":4,"57":4,"60":4}}],["called",{"2":{"52":1}}],["causes",{"2":{"52":1}}],["create",{"2":{"52":1}}],["code>run",{"2":{"52":2}}],["code>runnable",{"2":{"52":1}}],["code>",{"2":{"52":3}}],["code++",{"2":{"42":1}}],["contract",{"2":{"52":1}}],["con2",{"2":{"42":2}}],["con1",{"2":{"42":8}}],["con",{"2":{"42":2}}],["consumer",{"2":{"42":7,"55":1}}],["concurrent在并发编程中使用的工具包",{"2":{"5":1}}],["com3",{"2":{"37":2}}],["com2",{"2":{"37":2,"42":4}}],["compareto",{"2":{"42":4}}],["compare3",{"2":{"37":2}}],["compare2",{"2":{"37":2}}],["compare1",{"2":{"37":2}}],["compare",{"2":{"37":7,"42":5}}],["comparator",{"2":{"37":4,"42":5}}],["com1",{"2":{"37":2,"42":4}}],["c类通过接口去依赖d类",{"2":{"30":1}}],["c",{"2":{"30":10}}],["class",{"2":{"30":10,"34":2,"40":4,"41":3,"45":2,"46":4,"48":3,"54":3,"57":3,"60":3}}],["c++新手的区别就是前者手背上有很多伤疤",{"2":{"29":1}}],["c++老手和",{"2":{"29":1}}],["c++",{"2":{"29":1}}],["myinterface",{"2":{"52":1}}],["mysql是怎样运行的",{"2":{"6":1}}],["method1",{"2":{"52":1}}],["method",{"2":{"52":2,"54":1}}],["may",{"2":{"52":1}}],["mayers",{"2":{"29":1}}],["main",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1,"54":1,"57":1,"60":1}}],["你就懂了面向对象分析和设计",{"2":{"29":1}}],["懂了设计模式",{"2":{"29":1}}],["金句",{"2":{"29":1}}],["低耦合的特性",{"2":{"29":1}}],["使得以",{"2":{"38":1}}],["使程序呈现",{"2":{"29":1}}],["使用一个类",{"2":{"34":1}}],["使用lambda表达式可以写出更简洁更灵活的代码",{"2":{"31":1}}],["使用",{"2":{"30":4,"42":1}}],["使用接口或抽象类的目的是制定好规范",{"2":{"28":1}}],["使用到多种设计模式",{"2":{"22":1}}],["当",{"2":{"42":1}}],["当增加新的功能时",{"2":{"29":1}}],["当职责1需求变更而改变a时",{"2":{"21":1}}],["代码运行结果如下",{"2":{"45":1}}],["代码重用性",{"2":{"29":1}}],["代码更少",{"2":{"18":1}}],["软件测试等级划分",{"0":{"44":1},"1":{"49":1,"53":1,"56":1,"59":1,"62":1}}],["软件测试是软件产品质量保证的重要措施之一",{"2":{"33":1}}],["软件测试人员比其他人做软件测试工作",{"2":{"33":1}}],["软件测试职位本来带来的价值",{"2":{"33":1}}],["软件",{"2":{"29":1}}],["软件工程中",{"2":{"16":1}}],["灵活性等多方面的挑战",{"2":{"29":1}}],["重写的",{"2":{"48":1}}],["重写了父类的方法",{"2":{"48":1}}],["重用性",{"2":{"29":1}}],["重复功能太多",{"2":{"11":1}}],["内聚性及可维护性",{"2":{"29":1}}],["耦合性",{"2":{"29":1}}],["编程是一切",{"2":{"52":1}}],["编码完成后随意地测试和调试",{"2":{"49":1}}],["编写软件过程中",{"2":{"29":1}}],["编译器",{"2":{"18":1}}],["把展现的细节的任务交给他们的实现类去完成",{"2":{"28":1}}],["把应用拆分成为一个一个独立的单个服务",{"2":{"26":1}}],["细节就是具体的实现类",{"2":{"28":1}}],["细节应该依赖抽象",{"2":{"28":1}}],["中继承的思考和说明",{"0":{"32":1}}],["中",{"2":{"28":1}}],["相对于细节的多变性",{"2":{"28":1}}],["原则",{"2":{"36":1}}],["原则的中心思想是",{"2":{"28":1}}],["原有的单个业务系统会拆分为多个可以独立开发",{"2":{"26":1}}],["倒置",{"2":{"28":1,"36":1}}],["抽象方法",{"2":{"54":1,"57":1,"60":1}}],["抽象指的是接口或抽象类",{"2":{"28":1}}],["抽象的东西要更稳定",{"2":{"28":1}}],["抽象不应该依赖细节",{"2":{"28":1}}],["抽象类",{"2":{"28":1}}],["而且强烈依赖于代码",{"2":{"53":1}}],["而不是函数",{"2":{"52":1}}],["而不是依赖一个具体的子类",{"2":{"28":1}}],["而不涉及任何具体的操作",{"2":{"28":1}}],["而域名容易记住",{"2":{"17":1}}],["接收接口",{"2":{"54":1}}],["接收消息",{"2":{"41":1}}],["接口传递",{"0":{"54":1}}],["接口即可",{"2":{"41":1}}],["接口隔离原则",{"2":{"36":1}}],["接口3",{"2":{"30":1}}],["接口2",{"2":{"30":1}}],["接口1",{"2":{"30":1}}],["接口",{"0":{"52":1},"1":{"55":1},"2":{"28":1,"30":1}}],["接受维护项目",{"2":{"16":1}}],["如何理解函数式接口",{"2":{"52":1}}],["如何正确使用继承的原则",{"2":{"32":1}}],["如果lambda体只有一条执行语句",{"2":{"47":1}}],["如果lambda形参列表只有一个参数",{"2":{"47":1}}],["如果新增这些类",{"2":{"41":1}}],["如果对每个类型为",{"2":{"38":1}}],["如果一个类被其他的类所继承",{"2":{"32":1}}],["如下所示",{"2":{"34":1,"40":1,"45":1}}],["如",{"2":{"28":1}}],["如类a负责两个不同的职责",{"2":{"21":1}}],["二者都应该依赖其抽象",{"2":{"28":1}}],["documented",{"2":{"52":1}}],["description",{"2":{"30":1,"41":1,"46":1,"48":1}}],["dependencypass",{"2":{"54":1,"57":1,"60":1}}],["dependencyinversion",{"2":{"41":3,"46":4}}],["dependence",{"2":{"28":1}}],["dependecyinversion",{"2":{"41":1}}],["depend5",{"2":{"30":3}}],["depend4",{"2":{"30":3}}],["depend3",{"2":{"30":3}}],["depend2",{"2":{"30":3}}],["depend1",{"2":{"30":6}}],["date",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1}}],["d类",{"2":{"30":2}}],["d",{"2":{"29":1,"30":16}}],["dubbo",{"2":{"26":1}}],["以抽象为基础搭建的架构比以细节为基础搭建的架构要更稳定",{"2":{"28":1}}],["以交通工具运行为例",{"2":{"27":1}}],["以实现服务的共享和重用",{"2":{"14":1}}],["应用实例",{"0":{"27":1,"30":1,"35":1},"1":{"34":1,"40":1,"41":1,"45":1,"46":1}}],["应用场景",{"0":{"13":1},"1":{"17":1,"23":1}}],["运行结果",{"2":{"48":1}}],["运行代码结果如下",{"2":{"40":1}}],["运行代码输出结果如下",{"2":{"34":1}}],["运行的小应用",{"2":{"26":1}}],["运维",{"2":{"26":1}}],["测试用例和测试过程被管理起来",{"2":{"59":1}}],["测试成为一个可以测量和量化的过程",{"2":{"59":1}}],["测试组疲于应付",{"2":{"56":1}}],["测试不同于调试",{"2":{"53":1}}],["测试等同于调试",{"2":{"49":1}}],["测试是完全混乱无序的",{"2":{"49":1}}],["测试员",{"2":{"39":1}}],["测试",{"2":{"26":1,"30":1}}],["每个微服务有自己私有的数据库持久化业务数据",{"2":{"26":1}}],["去中心化",{"2":{"26":1}}],["特点",{"2":{"26":1}}],["+",{"2":{"26":2,"34":1,"40":3,"45":3,"48":7}}],["的和",{"2":{"48":1}}],["的子类型",{"2":{"38":1}}],["的行为没有发生变化",{"2":{"38":1}}],["的对象",{"2":{"38":2}}],["的精要",{"2":{"29":1}}],["的领域建模思想",{"2":{"26":1}}],["的组件化架构思想",{"2":{"26":1}}],["的soa服务架构思想",{"2":{"26":1}}],["的各种问题",{"2":{"16":1}}],["设计",{"2":{"26":1}}],["设计模式常用七大原则",{"0":{"36":1}}],["设计模式包含了面向对象的精髓",{"2":{"29":1}}],["设计模式是为了让程序",{"2":{"29":1}}],["设计模式的目的",{"0":{"29":1}}],["设计模式的重要性",{"0":{"16":1}}],["设计模式+数据结构",{"2":{"22":1}}],["设计模式在软件中哪里",{"0":{"22":1}}],["设计模式",{"2":{"16":1}}],["业务需要彻底的组件化和服务化",{"2":{"26":1}}],["上做的升华",{"2":{"26":1}}],["串行流",{"2":{"25":1}}],["并返回boolean值",{"2":{"55":1}}],["并返回结果",{"2":{"55":1}}],["并且可以有返回值",{"2":{"42":1}}],["并且修改后",{"2":{"32":1}}],["并用不同的线程分别处理每个数据块的流",{"2":{"25":1}}],["并行流就是把一个内容分为多个数据块",{"2":{"25":1}}],["并行流和串行流",{"0":{"25":1}}],["并通过这些服务之间定义良好的接口和契约联系起来",{"2":{"19":1}}],["各个客户端服务器监听这个znode",{"2":{"23":1}}],["配置管理可交由zookeeper实现",{"2":{"23":1}}],["配置文件同步非常常见",{"2":{"23":1}}],["希望能够快速同步到各个节点上",{"2":{"23":1}}],["对方案",{"2":{"46":1}}],["对类型为t的对象应用操作",{"2":{"55":2}}],["对类分解的同时",{"2":{"45":1}}],["对类来说",{"2":{"21":1}}],["对于属于接收消息范围的",{"2":{"41":1}}],["对于类c也是同理",{"2":{"30":1}}],["对该方案进行分析",{"2":{"41":1}}],["对原来功能没有影响",{"2":{"29":1}}],["对配置信息修改后",{"2":{"23":1}}],["统一配置管理",{"0":{"23":1}}],["统一命名服务",{"0":{"17":1}}],["架构",{"2":{"22":1}}],["架构演进",{"0":{"4":1},"1":{"8":1,"11":1,"14":1,"19":1,"26":1}}],["框架",{"2":{"22":1}}],["功能模块",{"2":{"22":1}}],["=",{"2":{"22":3,"26":1,"30":2,"34":1,"37":8,"40":3,"41":1,"42":12,"45":1,"46":1,"48":2,"54":2,"57":3,"60":3}}],["面向函数编程",{"2":{"52":1}}],["面向接口编程",{"2":{"28":1}}],["面向对象",{"0":{"32":1},"2":{"22":1}}],["面向服务的架构",{"2":{"19":1}}],["职责1和职责2",{"2":{"21":1}}],["即新建一个接口",{"2":{"52":1}}],["即求",{"2":{"48":1}}],["即在使用继承的过程中",{"2":{"48":1}}],["即在使用继承时",{"2":{"38":1}}],["即重写的抽象方法的方法体",{"2":{"42":1}}],["即接口中的抽象方法的形参列表",{"2":{"42":1}}],["即符合依赖倒转原则",{"2":{"41":1}}],["即有细节依赖抽象",{"2":{"41":1}}],["即将类分解",{"2":{"40":1}}],["即负责摩托车在公路上",{"2":{"34":1}}],["即",{"2":{"32":1,"38":1,"52":1}}],["即可以得到以下类图",{"2":{"30":1}}],["即增加新的功能时",{"2":{"29":1}}],["即编程规范",{"2":{"29":1}}],["即相同功能的代码",{"2":{"29":1}}],["即一个类对另外一个类的依赖应该建立在更小的接口上",{"2":{"24":1}}],["即一个类应该只负责一项职责",{"2":{"21":1}}],["即维护性",{"2":{"16":1}}],["监控告急等等",{"2":{"19":1}}],["异常处理",{"2":{"19":1}}],["加密处理",{"2":{"19":1}}],["流量控制",{"2":{"19":1}}],["负载均衡",{"2":{"19":1}}],["主要是提供了一个服务于服务之间的交互",{"2":{"19":1}}],["主要为学习各种开发技术专用",{"2":{"12":1}}],["企业服务总线",{"2":{"19":1}}],["elementtype",{"2":{"52":1}}],["executing",{"2":{"52":1}}],["extends",{"2":{"48":1}}],["email",{"2":{"41":6,"46":2}}],["effective",{"2":{"29":1}}],["enterparise",{"2":{"19":1}}],["esb",{"2":{"19":2}}],["进行优化",{"2":{"46":1}}],["进行拆分",{"2":{"19":1}}],["进程了解",{"2":{"9":1}}],["是类型",{"2":{"38":1}}],["是一个匿名函数",{"2":{"31":1}}],["是一个组件模型",{"2":{"19":1}}],["是指",{"2":{"28":1}}],["是soa时代的产物",{"2":{"26":1}}],["是对软件设计中普遍存在",{"2":{"16":1}}],["apply",{"2":{"55":1}}],["api",{"0":{"61":1},"2":{"18":1,"26":1}}],["auto",{"2":{"54":1}}],["author",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1}}],["abstract",{"2":{"52":1}}],["action",{"2":{"52":1}}],["accept",{"2":{"42":7,"55":1}}],["annotation",{"2":{"52":1}}],["any",{"2":{"52":1}}],["an",{"2":{"52":1}}],["a类",{"2":{"48":1}}],["a类通过接口去依赖b类",{"2":{"30":1}}],["airvehicle",{"2":{"40":5}}],["args",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1,"54":1,"57":1,"60":1}}],["architecture",{"2":{"19":1}}],["a",{"2":{"30":10,"48":7,"52":1}}],["a2",{"2":{"21":1}}],["of",{"2":{"52":1}}],["object",{"2":{"52":2}}],["o2",{"2":{"37":4,"38":2,"42":10}}],["o1",{"2":{"37":4,"38":2,"42":10}}],["override",{"2":{"37":2,"42":3,"46":2,"54":1,"57":1,"60":1}}],["out",{"2":{"30":16,"34":1,"37":7,"40":3,"41":1,"42":22,"45":3,"46":1,"48":6,"54":1,"57":1,"60":1}}],["open",{"2":{"54":3,"57":3,"60":3}}],["openandclose",{"2":{"54":3,"57":4,"60":3}}],["operation5",{"2":{"30":11}}],["operation4",{"2":{"30":11}}],["operation3",{"2":{"30":11}}],["operation2",{"2":{"30":11}}],["operation1",{"2":{"30":16}}],["optional类",{"0":{"64":1},"2":{"18":1}}],["oop",{"2":{"52":1}}],["ooa",{"2":{"29":1}}],["oo",{"0":{"32":1},"2":{"22":1}}],["oriented",{"2":{"19":1}}],["允许jvm上运行js应用",{"2":{"18":1}}],["supplier",{"2":{"55":1}}],["scala等语言的兴起和新技术的挑战",{"2":{"52":1}}],["scott",{"2":{"29":1}}],["s",{"2":{"42":12,"52":1}}],["singleresponsibility3",{"2":{"45":1}}],["singleresponsibility2",{"2":{"40":1}}],["singleresponsibility1",{"2":{"34":1}}],["singleresponsibility",{"2":{"34":1,"40":1,"45":1}}],["stub",{"2":{"54":1}}],["starting",{"2":{"52":1}}],["static",{"2":{"30":1,"34":1,"40":1,"41":1,"45":1,"46":1,"48":1,"54":1,"57":1,"60":1}}],["string>",{"2":{"42":7}}],["string",{"2":{"30":1,"34":2,"40":4,"41":2,"42":3,"45":4,"46":4,"48":1,"54":1,"57":1,"60":1}}],["stream",{"0":{"61":1},"2":{"18":1}}],["system",{"2":{"30":16,"34":1,"37":7,"40":3,"41":1,"42":22,"45":3,"46":1,"48":6}}],["settv",{"2":{"60":3}}],["setter",{"0":{"60":1}}],["see",{"2":{"52":1}}],["separately",{"2":{"52":1}}],["segregation1",{"2":{"30":3}}],["segregation",{"2":{"30":3}}],["servce",{"2":{"19":1}}],["service",{"2":{"19":1}}],["springcloud是微服务时代的产物",{"2":{"26":1}}],["soa",{"2":{"19":1,"26":1}}],["soa架构",{"0":{"19":1}}],["soap协议",{"2":{"14":1}}],["速度更快",{"2":{"18":1}}],["为什么需要软件测试",{"0":{"33":1}}],["为java语言",{"2":{"18":1}}],["为分布式框架提供协调服务的apache项目",{"2":{"7":1}}],["简介",{"0":{"18":1},"1":{"25":1}}],["简单的说",{"2":{"52":1}}],["简单",{"2":{"8":1,"41":1}}],["iopenandclose",{"2":{"54":2,"57":2,"60":2}}],["itv接口",{"2":{"54":1,"57":1,"60":1}}],["itv",{"2":{"54":4,"57":4,"60":5}}],["it",{"2":{"52":1}}],["is",{"2":{"52":2}}],["ireceiver",{"2":{"41":3,"46":4}}],["import",{"2":{"52":1}}],["implementing",{"2":{"52":1}}],["implements",{"2":{"30":4,"46":2,"54":2,"57":2,"60":2}}],["improve",{"2":{"30":1,"46":2}}],["i",{"2":{"30":24}}],["in",{"2":{"52":1}}],["int",{"2":{"37":4,"42":1,"48":9}}],["integer",{"2":{"37":5,"42":2}}],["integer>",{"2":{"37":4,"42":5}}],["interface3",{"2":{"30":4}}],["interface2",{"2":{"30":4}}],["interface1",{"2":{"30":14}}],["interface",{"2":{"30":4,"46":1,"52":4,"54":2,"57":2,"60":2}}],["inversion",{"2":{"28":1}}],["ip不容易记住",{"2":{"17":1}}],["idea工具熟练",{"2":{"9":1}}],["例如",{"2":{"17":1}}],["服务之间交互一般使用rest",{"2":{"26":1}}],["服务实现组件化",{"2":{"26":1}}],["服务器集群",{"2":{"22":1}}],["服务的监控",{"2":{"19":1}}],["服务中介",{"2":{"19":1}}],["服务进行统一命名",{"2":{"17":1}}],["服务提供方一旦产生变更",{"2":{"14":1}}],["经常需要对应用",{"2":{"17":1}}],["在整个软件生存周期中没有建立正式的评审程序",{"2":{"56":1}}],["在需求和设计中没有测试",{"2":{"53":1}}],["在将函数作为一等公民的编程语言中",{"2":{"52":1}}],["在函数式编程语言当中",{"2":{"52":1}}],["在java8中",{"2":{"52":2}}],["在java里面面向对象",{"2":{"52":1}}],["在java中的lang包中存在的一个函数式接口",{"2":{"52":1}}],["在水中上运行",{"2":{"45":2}}],["在天空上运行",{"2":{"45":2}}],["在适当的情况下",{"2":{"38":1}}],["在子类中尽量不要重写父类的方法",{"2":{"38":1}}],["在所有的对象",{"2":{"38":1}}],["在公路上运行",{"2":{"34":4,"45":2}}],["在其巨著",{"2":{"29":1}}],["在",{"2":{"28":1}}],["在分布式环境下",{"2":{"17":1,"23":1}}],["在多个单体架构中",{"2":{"11":1}}],["怎么使用的",{"2":{"16":1}}],["大厂提问",{"2":{"16":1}}],["规范性",{"2":{"16":1}}],["所以以前用",{"2":{"52":1}}],["所以根据依赖倒转原则进行分析",{"2":{"41":1}}],["所以我们可以将接口interface1拆分为几个接口",{"2":{"30":1}}],["所以需要将类a的粒度分解为a1",{"2":{"21":1}}],["所有测试都是基于执行的",{"2":{"53":1}}],["所有的引用基类的地方必须能透明的使用其子类的对象",{"2":{"38":1}}],["所有节点的配置信息是一致的",{"2":{"23":1}}],["所有消费方都需要变更",{"2":{"14":1}}],["所提出的解决方案",{"2":{"16":1}}],["反复出现",{"2":{"16":1}}],["图解+框架源码剖析",{"2":{"15":1}}],["尚硅谷java设计模式",{"2":{"15":1}}],["hello",{"2":{"41":2,"46":4}}],["hession等等",{"2":{"14":1}}],["http",{"2":{"14":1}}],["r",{"2":{"55":3}}],["roadvehicle",{"2":{"40":6}}],["retentionpolicy",{"2":{"52":1}}],["retention",{"2":{"52":1}}],["return",{"2":{"37":1,"41":1,"42":4,"46":2,"48":3}}],["receiver",{"2":{"46":2}}],["receive",{"2":{"41":2,"46":3}}],["rest风格",{"2":{"14":1}}],["r2",{"2":{"37":2,"42":2}}],["r1",{"2":{"37":2,"42":2}}],["runtime",{"2":{"52":1}}],["runair",{"2":{"45":2}}],["runwater",{"2":{"45":2}}],["runnable",{"2":{"37":3,"42":3,"52":1}}],["run",{"2":{"34":4,"37":3,"40":6,"42":3,"45":2,"52":2}}],["rmi规范",{"2":{"14":1}}],["rpc",{"2":{"14":1}}],["比如使用继承会给程序带来侵入性",{"2":{"32":1}}],["比如kafka集群",{"2":{"23":1}}],["比如",{"2":{"14":1}}],["远程过程调用",{"2":{"14":1}}],["将测试看做专业化的活动",{"2":{"56":1}}],["将测试集成到整个软件生存周期",{"2":{"56":1}}],["将测试定义为编码完成后的阶段和工作",{"2":{"53":1}}],["将交通工具类的不同",{"2":{"40":1}}],["将该类进行拆分",{"2":{"34":1}}],["将代码像数据一样进行传递",{"2":{"31":1}}],["将公共业务模块抽取出来",{"2":{"14":1}}],["将单体架构中的多个模块拆分为多个独立的项目",{"2":{"11":1}}],["提供的服务",{"2":{"13":1}}],["提高类的可读性",{"2":{"50":1}}],["提高",{"2":{"1":1}}],["介绍",{"0":{"12":1}}],["形成多个独立的单体架构",{"2":{"11":1}}],["垂直架构是指",{"2":{"11":1}}],["垂直架构",{"0":{"11":1}}],["工作机制",{"0":{"10":1}}],["有所不同",{"2":{"52":1}}],["有非常多的协议和技术都实现了rpc的过程",{"2":{"14":1}}],["有一定线程",{"2":{"9":1}}],["有java基础",{"2":{"9":1}}],["了解java新特性",{"2":{"9":1}}],["前置知识",{"0":{"9":1}}],["性能低",{"2":{"8":1}}],["可维护性",{"2":{"50":1}}],["可以度量和优化产品质量",{"2":{"62":1}}],["可以加上",{"2":{"52":1}}],["可以省略",{"2":{"47":2}}],["可以通过聚合",{"2":{"38":1}}],["可以把lambda表达式理解为一段可以传递的代码",{"2":{"31":1}}],["可以发现",{"2":{"30":1}}],["可以查看下面的实现代码",{"2":{"30":1}}],["可以很大程度上提高程序的执行效率",{"2":{"25":1}}],["可靠性",{"2":{"29":1}}],["可靠性差",{"2":{"8":1}}],["可扩展性",{"2":{"29":1}}],["可扩展性和可维护性差",{"2":{"8":1}}],["可将配置信息写入zookeeper上的一个znode",{"2":{"23":1}}],["可能是",{"2":{"48":1}}],["可能是return语句",{"2":{"47":1}}],["可能还以为调用的是父类的func1方法",{"2":{"48":1}}],["可能意识的重写了父类的方法",{"2":{"48":1}}],["可能会对整个继承体系造成破坏",{"2":{"32":1}}],["可能造成职责2执行错误",{"2":{"21":1}}],["可能存在重复模块",{"2":{"11":1}}],["可读性",{"2":{"16":1,"29":1}}],["可伸缩性差",{"2":{"8":1}}],["可伸缩",{"2":{"1":1}}],["项目经理",{"2":{"39":1}}],["项目启动慢",{"2":{"8":1}}],["项目架构目标",{"0":{"1":1}}],["缺点",{"2":{"8":1}}],["小型项目首选",{"2":{"8":1}}],["zookeeper是一个开源的分布式的",{"2":{"7":1}}],["概述",{"0":{"7":1},"1":{"10":1,"13":1,"17":1,"23":1}}],["学习书籍",{"0":{"6":1,"20":1}}],["学习视频",{"0":{"3":1,"15":1}}],["java中四大核心函数式接口",{"2":{"55":1}}],["java内置函数式接口",{"0":{"55":1}}],["java不但可以支持oop还可以支持oof",{"2":{"52":1}}],["java不得不做出调整以便支持更加广泛的技术要求",{"2":{"52":1}}],["java从诞生日起就是一直倡导",{"2":{"52":1}}],["java8",{"2":{"18":1}}],["java8新特性",{"2":{"9":1}}],["java",{"2":{"5":1,"14":1,"28":1,"52":4}}],["juc入门",{"2":{"9":1}}],["juc是什么",{"0":{"5":1}}],["juc并发编程",{"2":{"3":1}}],["指",{"2":{"5":1}}],["分析",{"2":{"40":1,"45":1}}],["分解成不同的类",{"2":{"34":1,"40":1}}],["分别部署在不同的机器上",{"2":{"2":1}}],["分布式架构是指在垂直架构的基础上",{"2":{"14":1}}],["分布式架构",{"0":{"14":1}}],["分布式",{"2":{"2":1}}],["拆分为小的业务模块",{"2":{"2":1}}],["干不一样的事",{"2":{"2":1}}],["干一样的事情",{"2":{"2":1}}],["部署在多台服务器上",{"2":{"2":1}}],["一切皆对象",{"2":{"52":1}}],["一旦znode中的数据发生修改",{"2":{"23":1}}],["一边要求一个集群中",{"2":{"23":1}}],["一个类只负责一种职责",{"2":{"50":1}}],["一个类对于另一个类的依赖应该建立在最小接口上",{"2":{"30":1}}],["一个大的业务系统",{"2":{"2":1}}],["一个业务模块",{"2":{"2":1}}],["一起",{"2":{"2":2}}],["人们掌握了一定的测试技术和方法",{"2":{"53":1}}],["人",{"2":{"2":2}}],["quot",{"2":{"2":4}}],["很多",{"2":{"2":2}}],["快速响应",{"2":{"1":1}}],["快速的访问体验",{"2":{"1":1}}],["随需应变",{"2":{"1":1}}],["敏捷性",{"2":{"1":1}}],["安全访问和数据加密",{"2":{"1":1}}],["安全性",{"2":{"1":1}}],["系统间耦合低",{"2":{"1":1}}],["减少",{"2":{"1":1}}],["网站服务一直可以正常访问",{"2":{"1":1}}],["高内聚",{"2":{"29":1}}],["高层模块不应该依赖底层模块",{"2":{"28":1}}],["高可扩展",{"2":{"1":1}}],["高可用",{"2":{"1":1}}],["高性能",{"2":{"1":1}}],["画类图",{"0":{"0":1}}]],"serializationVersion":2}';export{t as default};
