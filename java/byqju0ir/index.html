<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.9" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.53" /><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();</script><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><meta property="og:url" content="https://ytazwc.top/blogs/java/byqju0ir/"><meta property="og:site_name" content="花木凋零成兰"><meta property="og:title" content="面向对象特性"><meta property="og:description" content="面向对象 参考资料 面向对象特性: 深入理解Java三大特性：封装、继承和多态 多态: 理解Java中的多态机制,一篇文章帮你掌握 向上转型和向下转型 Java编程思想_第5版_中文 继承: Java的作者为什么拒绝设计支持多继承关系？ 面向对象特性 三大特征为: 封装,继承,多态; 合理运用能提高代码复用性 封装 封装, 即包装的意思, 是对信息进行..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-05-03T05:25:06.000Z"><meta property="article:author" content="花木凋零成兰"><meta property="article:modified_time" content="2024-05-03T05:25:06.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"面向对象特性","image":[""],"dateModified":"2024-05-03T05:25:06.000Z","author":[{"@type":"Person","name":"花木凋零成兰"}]}</script><link rel="icon" type="image/avif" href="/images/ok.avif"><title>面向对象特性 | 花木凋零成兰</title><meta name="description" content="面向对象 参考资料 面向对象特性: 深入理解Java三大特性：封装、继承和多态 多态: 理解Java中的多态机制,一篇文章帮你掌握 向上转型和向下转型 Java编程思想_第5版_中文 继承: Java的作者为什么拒绝设计支持多继承关系？ 面向对象特性 三大特征为: 封装,继承,多态; 合理运用能提高代码复用性 封装 封装, 即包装的意思, 是对信息进行..."><link rel="preload" href="/blogs/assets/style-MyST9v-W.css" as="style"><link rel="stylesheet" href="/blogs/assets/style-MyST9v-W.css"><link rel="modulepreload" href="/blogs/assets/app-5Dm3QmMW.js"><link rel="modulepreload" href="/blogs/assets/index.html-Px-p7woK.js"><link rel="prefetch" href="/blogs/assets/index.html-exjlB2L3.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-_-soxVD2.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BWRz_DoZ.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-B-IqowHy.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DWOARF9A.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CvyqttmU.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-D6aLc1UY.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DCE3XuD_.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-C9q9FbX4.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-C5bEwiX1.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CeQqxHTB.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DFfqaZw4.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-Dm19QJiA.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-ByAcRilJ.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-uWS7H3_K.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-D4sFBU9y.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BjtS1zoM.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DMZKgQiZ.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-8tqMqsKU.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DvtCI6gy.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CICwvDWD.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-EznxqK_6.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-fRhK6aF4.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DQqJS0PV.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-jU-b9za4.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-8IJP8P0e.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-C36ajbUR.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-c_6hBfir.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-niCwUY8W.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BGopSaJB.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BQT0gSzk.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BqyfHk7e.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-HmHiKNqa.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-Cl6J910b.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-C4qE4IaF.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DBNhsAb5.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CZbkmVin.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BqimIy-5.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DIPlmmh9.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DMLjNsKj.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CcSoZ3j9.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-C7ADPkn8.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CrIrV2Wc.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-dhg9F0H1.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-BH97TZ9U.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-CWE0-9qk.js" as="script"><link rel="prefetch" href="/blogs/assets/404.html-wIlshsbm.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-UvBxCzQ5.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DL-ANnDq.js" as="script"><link rel="prefetch" href="/blogs/assets/index.html-DuNiiT1S.js" as="script"><link rel="prefetch" href="/blogs/assets/SearchBox-rdI3Z4tn.js" as="script"><link rel="prefetch" href="/blogs/assets/mermaid.core-DDxU7VhZ.js" as="script"></head><body><div id="app"><!--[--><div class="theme-plume" data-v-a5c639d0><!--[--><!--[--><span tabindex="-1" data-v-72372f0f></span><a href="#LayoutContent" class="skip-link visually-hidden" data-v-72372f0f> Skip to content </a><!--]--><!----><div class="nav-wrapper" data-v-a5c639d0 data-v-ab1efab5><div class="navbar-wrapper has-sidebar" data-v-ab1efab5 data-v-7f74ef57><div class="container" data-v-7f74ef57><div class="title" data-v-7f74ef57><div class="navbar-title has-sidebar" data-v-7f74ef57 data-v-5bc7a806><a class="auto-link link title" href="/" data-v-5bc7a806 data-v-9dcd60c1><!--[--><!--[--><!--[--><!--[--><img class="plume-image dark logo" src="/blogs/images/ok.avif" alt data-v-ad923c05><!--]--><!--[--><img class="plume-image light logo" src="/blogs/images/ok.avif" alt data-v-ad923c05><!--]--><!--]--><!--]--> 花木凋零成兰<!--]--><!----></a></div></div><div class="content" data-v-7f74ef57><div class="curtain" data-v-7f74ef57></div><div class="content-body" data-v-7f74ef57><div class="navbar-search search" data-v-7f74ef57><div class="search-wrapper" data-v-e332515b><!----><div id="local-search" data-v-e332515b><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-e332515b><span class="mini-search-button-container"><svg class="mini-search-search-icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><nav aria-labelledby="main-nav-aria-label" class="navbar-menu menu" data-v-7f74ef57 data-v-abd56a63><span id="main-nav-aria-label" class="visually-hidden" data-v-abd56a63>Main Navigation</span><!--[--><!--[--><a class="auto-link link navbar-menu-link" href="/" data-v-abd56a63 data-v-cb73c46e data-v-9dcd60c1><!--[--><!----><i data-v-cb73c46e>首页</i><!--]--><!----></a><!--]--><!--[--><a class="auto-link link navbar-menu-link" href="/blog/" data-v-abd56a63 data-v-cb73c46e data-v-9dcd60c1><!--[--><!----><i data-v-cb73c46e>博客</i><!--]--><!----></a><!--]--><!--[--><div class="flyout-wrapper navbar-menu-group" data-v-abd56a63 data-v-8119e2dc><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-8119e2dc><span class="text" data-v-8119e2dc><!----><!----><span data-v-8119e2dc>我的</span><span class="vpi-chevron-down text-icon" data-v-8119e2dc></span></span></button><div class="menu" data-v-8119e2dc><div class="menu-wrapper" data-v-8119e2dc data-v-056d3421><div class="items" data-v-056d3421><!--[--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="https://github.com/YTAZWC" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Github</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="https://gitee.com/ytaml" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Gitee</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="https://blog.csdn.net/qq_61457746" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>CSDN</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="https://ytazwc.top" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>旧博客</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="mailto:18570354653@163.com" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>邮箱</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="flyout-wrapper navbar-menu-group" data-v-abd56a63 data-v-8119e2dc><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-8119e2dc><span class="text" data-v-8119e2dc><!----><!----><span data-v-8119e2dc>笔记</span><span class="vpi-chevron-down text-icon" data-v-8119e2dc></span></span></button><div class="menu" data-v-8119e2dc><div class="menu-wrapper" data-v-8119e2dc data-v-056d3421><div class="items" data-v-056d3421><!--[--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/kamacoder/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>卡码网刷题</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/java/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Java重点学习</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/leetcode/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Leetcode刷题</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/learn/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>开发学习</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/design-pattern/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>设计模式</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/java-concurrent/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Java并发</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/mysql-learn/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>MySQL学习</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/zookeeper/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Zookeeper</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/dubbo/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Dubbo</i><!--]--><!----></a></div><!--]--><!--[--><div class="menu-link" data-v-056d3421 data-v-820f0f1e><a class="auto-link link" href="/test-quality/" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>软件测试与质量</i><!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="flyout-wrapper navbar-menu-group" data-v-abd56a63 data-v-8119e2dc><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-8119e2dc><span class="text" data-v-8119e2dc><!----><!----><span data-v-8119e2dc>文档</span><span class="vpi-chevron-down text-icon" data-v-8119e2dc></span></span></button><div class="menu" data-v-8119e2dc><div class="menu-wrapper" data-v-8119e2dc data-v-056d3421><div class="items" data-v-056d3421><!--[--><!--[--><div class="menu-group" data-v-056d3421 data-v-e6c1bcb3><p class="title" data-v-e6c1bcb3><!----><span data-v-e6c1bcb3>开发文档</span></p><!--[--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://cn.dubbo.apache.org/zh-cn/overview/home/" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Dubbo</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="menu-group" data-v-056d3421 data-v-e6c1bcb3><p class="title" data-v-e6c1bcb3><!----><span data-v-e6c1bcb3>Blog文档</span></p><!--[--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://plume.pengzhanbo.cn/" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>指南</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://github.com/pengzhanbo/vuepress-theme-plume" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>源代码</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://pengzhanbo.cn/" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Demo</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="menu-group" data-v-056d3421 data-v-e6c1bcb3><p class="title" data-v-e6c1bcb3><!----><span data-v-e6c1bcb3>资源等</span></p><!--[--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://icon-sets.iconify.design/" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>图标库</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://mermaid.nodejs.cn/" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>Mermaid中文网</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--[--><div class="menu-link" data-v-e6c1bcb3 data-v-820f0f1e><a class="auto-link link" href="https://www.deepl.com/zh/translator" target="_blank" rel="noreferrer" data-v-820f0f1e data-v-9dcd60c1><!--[--><!----><i data-v-820f0f1e>在线翻译DeepL</i><!--]--><span class="vpi-external-link icon" data-v-9dcd60c1></span></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="navbar-appearance appearance" data-v-7f74ef57 data-v-4e10e44e><button class="switch-wrapper switch-appearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-4e10e44e data-v-1087fbd6 data-v-84e6883b><span class="check" data-v-84e6883b><span class="icon" data-v-84e6883b><!--[--><span class="vpi-sun sun" data-v-1087fbd6></span><span class="vpi-moon moon" data-v-1087fbd6></span><!--]--></span></span></button></div><!----><div class="flyout-wrapper navbar-extra extra" data-v-7f74ef57 data-v-4caa222c data-v-8119e2dc><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-8119e2dc><span class="vpi-more-horizontal icon" data-v-8119e2dc></span></button><div class="menu" data-v-8119e2dc><div class="menu-wrapper" data-v-8119e2dc data-v-056d3421><!----><!--[--><!--[--><!----><div class="group" data-v-4caa222c><div class="item appearance" data-v-4caa222c><p class="label" data-v-4caa222c>外观</p><div class="appearance-action" data-v-4caa222c><button class="switch-wrapper switch-appearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-4caa222c data-v-1087fbd6 data-v-84e6883b><span class="check" data-v-84e6883b><span class="icon" data-v-84e6883b><!--[--><span class="vpi-sun sun" data-v-1087fbd6></span><span class="vpi-moon moon" data-v-1087fbd6></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><button type="button" class="navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-7f74ef57 data-v-bcc0bf40><span class="container" data-v-bcc0bf40><span class="top" data-v-bcc0bf40></span><span class="middle" data-v-bcc0bf40></span><span class="bottom" data-v-bcc0bf40></span></span></button></div></div></div></div><!----></div><div class="local-nav reached-top" data-v-a5c639d0 data-v-7667d6fc><button class="menu" aria-expanded="false" aria-controls="SidebarNav" data-v-7667d6fc><span class="vpi-align-left menu-icon" data-v-7667d6fc></span><span class="menu-text" data-v-7667d6fc>Menu</span></button><div class="local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-7667d6fc data-v-a15b2457><button class="" data-v-a15b2457>此页内容 <span class="vpi-chevron-right icon" data-v-a15b2457></span></button><!----></div></div><aside class="sidebar-wrapper" data-v-a5c639d0 data-v-b83373ae><div class="curtain" data-v-b83373ae></div><nav id="SidebarNav" class="nav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b83373ae><span id="sidebar-aria-label" class="visually-hidden" data-v-b83373ae> Sidebar Navigation </span><!--[--><div class="group" data-v-b83373ae><section class="sidebar-item level-0" data-v-b83373ae data-v-7557a208><!----><div class="items" data-v-7557a208><!--[--><div class="sidebar-item level-1 is-link" data-v-7557a208 data-v-7557a208><div class="item" tabindex="0" data-v-7557a208><div class="indicator" data-v-7557a208></div><!----><a class="auto-link link link" href="/java/" data-v-7557a208 data-v-9dcd60c1><!--[--><p class="text" data-v-7557a208>Java重点学习</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><div class="group" data-v-b83373ae><section class="sidebar-item level-0 collapsible has-active" data-v-b83373ae data-v-7557a208><div class="item" role="button" tabindex="0" data-v-7557a208><div class="indicator" data-v-7557a208></div><!----><h2 class="text" data-v-7557a208>基础核心</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-7557a208><span class="vpi-chevron-right caret-icon" data-v-7557a208></span></div></div><div class="items" data-v-7557a208><!--[--><div class="sidebar-item level-1 is-link" data-v-7557a208 data-v-7557a208><div class="item" tabindex="0" data-v-7557a208><div class="indicator" data-v-7557a208></div><!----><a class="auto-link link link" href="/java/byqju0ir/" data-v-7557a208 data-v-9dcd60c1><!--[--><p class="text" data-v-7557a208>面向对象特性</p><!--]--><!----></a><!----></div><!----></div><!--]--></div></section></div><!--]--></nav></aside><div id="LayoutContent" class="layout-content has-sidebar" data-v-a5c639d0 data-v-33ce4d7f><!--[--><div class="has-sidebar has-aside plume-page" data-v-4ad3b558><div class="container" data-v-4ad3b558><div class="aside" data-v-4ad3b558><div class="aside-container" data-v-4ad3b558><div class="aside-content" data-v-4ad3b558><div class="page-aside" data-v-4ad3b558 data-v-7b38e69d><div class="has-outline page-aside-outline" data-v-7b38e69d><div class="content" data-v-7b38e69d><div class="outline-marker" data-v-7b38e69d></div><div class="outline-title" data-v-7b38e69d><span data-v-7b38e69d>此页内容</span><span class="vpi-print icon" data-v-7b38e69d></span></div><nav aria-labelledby="doc-outline-aria-label" data-v-7b38e69d><span id="doc-outline-aria-label" class="visually-hidden" data-v-7b38e69d> Table of Contents for current page </span><ul class="root" data-v-7b38e69d data-v-6a816aae><!--[--><li data-v-6a816aae><a class="outline-link" href="#面向对象" data-v-6a816aae>面向对象</a><ul class="nested" data-v-6a816aae data-v-6a816aae><!--[--><li data-v-6a816aae><a class="outline-link" href="#参考资料" data-v-6a816aae>参考资料</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#面向对象特性" data-v-6a816aae>面向对象特性</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#多态-1" data-v-6a816aae>多态</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#继承-1" data-v-6a816aae>继承</a><!----></li><!--]--></ul></li><li data-v-6a816aae><a class="outline-link" href="#抽象类和接口" data-v-6a816aae>抽象类和接口</a><ul class="nested" data-v-6a816aae data-v-6a816aae><!--[--><li data-v-6a816aae><a class="outline-link" href="#参考资料-1" data-v-6a816aae>参考资料</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#接口和抽象类区别" data-v-6a816aae>接口和抽象类区别</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#接口" data-v-6a816aae>接口</a><!----></li><!--]--></ul></li><li data-v-6a816aae><a class="outline-link" href="#方法重写和重载" data-v-6a816aae>方法重写和重载</a><ul class="nested" data-v-6a816aae data-v-6a816aae><!--[--><li data-v-6a816aae><a class="outline-link" href="#参考资料-2" data-v-6a816aae>参考资料</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#重载和重写的区别" data-v-6a816aae>重载和重写的区别</a><!----></li><!--]--></ul></li><li data-v-6a816aae><a class="outline-link" href="#内部类" data-v-6a816aae>内部类</a><ul class="nested" data-v-6a816aae data-v-6a816aae><!--[--><li data-v-6a816aae><a class="outline-link" href="#参考资料-3" data-v-6a816aae>参考资料</a><!----></li><li data-v-6a816aae><a class="outline-link" href="#内部类-1" data-v-6a816aae>内部类</a><!----></li><!--]--></ul></li><li data-v-6a816aae><a class="outline-link" href="#重点掌握检测" data-v-6a816aae>重点掌握检测</a><!----></li><!--]--></ul></nav></div></div></div></div></div></div><div class="content" data-v-4ad3b558><div class="content-container" data-v-4ad3b558><!--[--><!----><h1 class="page-title" data-v-ff34fbc5>面向对象特性</h1><div class="page-meta-wrapper" data-v-ff34fbc5><p class="author" data-v-ff34fbc5><span class="icon vpi-user" data-v-ff34fbc5></span><span data-v-ff34fbc5>花木凋零成兰</span></p><p class="reading-time" data-v-ff34fbc5><span class="vpi-books icon" data-v-ff34fbc5></span><span data-v-ff34fbc5>6152字</span><span data-v-ff34fbc5>约21分钟</span></p><!----><p class="create-time" data-v-ff34fbc5><span class="vpi-clock icon" data-v-ff34fbc5></span><span data-v-ff34fbc5>2024-04-28</span></p></div><!--]--><!--[--><div style="position:relative;" data-v-4ad3b558><div class="plume-content" data-v-4ad3b558><h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h2><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h3><p>面向对象特性: <a href="https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html" target="_blank" rel="noopener noreferrer">深入理解Java三大特性：封装、继承和多态<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></p><p>多态:</p><ul><li><a href="https://segmentfault.com/a/1190000022705651" target="_blank" rel="noopener noreferrer">理解Java中的多态机制,一篇文章帮你掌握<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li><li><a href="https://www.bilibili.com/video/BV1Rj411F7Z2/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0" target="_blank" rel="noopener noreferrer">向上转型和向下转型<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li><li><a href="https://gitee.com/code_to_attack/onJava8/blob/master/docs/book/09-Polymorphism.md" target="_blank" rel="noopener noreferrer">Java编程思想_第5版_中文<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><p>继承:</p><ul><li><a href="https://www.bilibili.com/video/BV14o4y1h7ri/?spm_id_from=333.788&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0" target="_blank" rel="noopener noreferrer">Java的作者为什么拒绝设计支持多继承关系？<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h3 id="面向对象特性" tabindex="-1"><a class="header-anchor" href="#面向对象特性"><span>面向对象特性</span></a></h3><p>三大特征为: 封装,继承,多态; 合理运用能<strong>提高代码复用性</strong></p><h4 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h4><p>封装, 即包装的意思, 是对信息进行隐藏, <strong>指利用抽象将数据和基于数据的操作封装在一起,使其构成一个不可分割的独立实体</strong>.</p><p>数据保护在类的内部, 尽可能隐藏内部细节, 只对外开放部分接口,于外界联系;</p><p>其他对象只能通过 开放的接口与封装的类进行交互, 即用户不需要知道对象内部的细节, 通过对象对外提供的接口来访问该对象;</p><p>好处:</p><ol><li>良好的封装能减少耦合</li><li>类内部的结构可以自由修改</li><li>可以对成员 实现更精确的控制</li><li>隐藏信息, 实现细节</li></ol><h4 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h4><p>继承 是面向对象软件技术中的一个概念, 使得<strong>复用以前的代码非常容易</strong>;</p><p>在Java中, <strong>继承就是 子类继承父类 的属性和方法, 使得子类对象(实例)具有父类的属性和方法, 或子类从父类继承方法, ,使得子类具有父类相同得方法</strong>.</p><ul><li>为什么使用继承? <ul><li>继承可以减少代码量, 使得代码结构更加清晰可见</li></ul></li></ul><h5 id="继承的分类" tabindex="-1"><a class="header-anchor" href="#继承的分类"><span>继承的分类</span></a></h5><p>继承分为单继承和多继承, Java只支持类的单继承, 但是可以通过实现接口的方式达到多继承目的;</p><table><thead><tr><th>继承</th><th>定义</th><th>优缺点</th></tr></thead><tbody><tr><td>单继承</td><td>一个子类只能有一个父类</td><td>优点: <strong>在类层次结构上比较清晰</strong> <br> 缺点: <strong>结构的丰富度不能满足使用需求</strong></td></tr><tr><td>多继承(Java不支持,通过其他方式来实现)</td><td>一个子类拥有多个直接的父类</td><td>优点: <strong>子类的丰富度很高</strong> <br> 缺点: <strong>容易造成混乱</strong></td></tr></tbody></table><p><strong>Java实现多继承的方式</strong> 一共有三种:</p><ol><li>内部类: 内部类可以继承一个与外部类无关的类, 保证了内部类的独立性, 基于该点,达到多继承的效果</li><li><strong>多层继承</strong>: <strong>子类继承父类,父类如果还继承其他的类, 即为多层继承</strong>, 这样子类会拥有所有被继承类的属性和方法</li><li><mark><strong>实现接口</strong></mark> : 是满足多继承使用需求最好的方式, 类可以实现多个接口满足自己的丰富性和复杂环境的使用需求</li></ol><h5 id="实现继承" tabindex="-1"><a class="header-anchor" href="#实现继承"><span>实现继承</span></a></h5><p>使用<code>extends</code>关键字, 实现单一继承, 子类继承父类后, 只能使用父类非私有的属性和方法(<a href="https://blog.csdn.net/shadow_zed/article/details/82182087" target="_blank" rel="noopener noreferrer">虽然持有父类的私有属性和私有方法,但是子类无法使用<span class="vpi-external-link external-icon" data-v-22577cb5></span></a>)</p><p>使用<code>implements</code>关键字, 可以变相使Java拥有多继承的特性, 使用范围为类实现接口的情况, 一个类可以实现多个接口</p><h5 id="继承的特点" tabindex="-1"><a class="header-anchor" href="#继承的特点"><span>继承的特点</span></a></h5><p>继承主要就是; 子类继承父类,并重写父类方法(注意重写和重载的区别), 同时也会使用到<code>super</code>和<code>this</code>关键字</p><p>this关键字, 表示当前对象, 是指向自己的引用:</p><ul><li>this.属性; 调用成员变量</li><li>this.(); 调用本类中的某个方法</li><li>this(); 调用本类的构造方法</li></ul><p>super关键字, 表示父类对象, 是指向父类的引用:</p><ul><li>super.属性; 调用父类成员变量</li><li>super.(); 调用本父类中的某个方法</li><li>super(); 调用父类的构造方法</li></ul><p><strong>构造方法</strong></p><p>与类同名的方法, 且父类构造方法不能被继承, <strong>子类的构造过程必须调用其父类的构造方法</strong>(Java虚拟机<strong>构造子类对象前,会先构造父类对象, 父类对象构造完成后再来构造子类特有的属性, 这被称为内存叠加;</strong> 而Java虚拟机构造父类对象会执行父类的构造方法,所以子类的构造过程必须调用其父类的构造方法)</p><p><mark>如果子类构造方法中,没有显示的调用父类构造方法, 系统会默认调用父类无参数的构造方法</mark></p><p><strong>方法重写(Override)</strong>; 即子类中出现和父类一摸一样的方法(返回值类型,方法名,参数列表均一样) 建立在继承的基础上, 即<strong>方法外壳不变,核心内容重写</strong></p><p><strong>方法重载(Overload)</strong>; 两个方法方法名相同, 但参数列表(包括参数排列顺序)不一致; 可以理解为完成一个事情的方法名相同, 但是参数列表不同其他条件也可能不同</p><h5 id="继承与修饰符" tabindex="-1"><a class="header-anchor" href="#继承与修饰符"><span>继承与修饰符</span></a></h5><p><strong>访问修饰符</strong>;</p><ul><li>子类重写父类方法时, <strong>不可以降低方法的访问权限</strong>,子类继承父类的访问修饰符作用域不能比父类小</li><li><strong>子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常</strong></li></ul><p><strong>非访问修饰符:</strong></p><ul><li>static; 可以修饰变量,方法,称为静态变量,静态方法(也称<strong>类变量,类方法</strong>) <ul><li>被static修饰的变量或方法, 可以直接通过类进行访问, 即<code>类名.方法名</code>, 比如说<code>Math</code>,<code>Arrays</code></li><li>构造方法不能使用static修饰</li><li>静态方法 不能被非静态方法重写</li></ul></li><li>final 变量; <strong>变量一旦被赋值后, 不能被重新赋值</strong>, 且被final修饰的实例变量必须显示指定初始值, 通过和static修饰符一起来创建类变量 <ul><li><strong>父类中的final方法可以被子类继承, 但是不能被子类重写</strong>, 声明final方法的主要目的 就是防止该方法内容被修改</li><li><strong>final类不能被继承</strong></li></ul></li><li>abstract; 用来修饰类和方法, 称为抽象类和抽象方法 <ul><li>抽象方法, 可以表达概念,但是无法具体实现</li><li>抽象类, <strong>有抽象方法的类必须是抽象类</strong>, 抽象类可以表达概念,但是无法构造实体的类</li></ul></li></ul><h5 id="object类和转型" tabindex="-1"><a class="header-anchor" href="#object类和转型"><span>Object类和转型</span></a></h5><p>Object(java.lang.Object)类, 是所有类的根类, 如果类没有显示声明父类, 则默认父类为Object类;</p><p><strong>Object类概述</strong>:</p><ol><li>是类层次结构的根类, 所有类都隐式继承自Object类</li><li>所有对象都拥有Object的默认方法</li><li>Object类, 有一个构造方法, 且是 <strong>无参构造方法</strong></li></ol><p><strong>向上转型:</strong> 通过子类对象(小范围)实例化父类对象(大范围), 属于自动转换; 即父类引用变量指向子类对象后, <strong>只能使用父类已经声明的方法</strong>, 但是如果方法被重写, 则会执行子类重写的方法, 未被重写,则执行父类的方法</p><p><strong>向下转型:</strong> 通过父类对象(大范围)实例化子类对象(小范围), 需要进行强制转换; 但<strong>前提是,强转的父类引用变量实际上引用的就是子类对象,才能成功转型</strong>, 强转后, 可以调用父类没有,子类特有的方法</p><h5 id="子父类初始化顺序" tabindex="-1"><a class="header-anchor" href="#子父类初始化顺序"><span>子父类初始化顺序</span></a></h5><p>在Java继承中, 父子类初始化顺序如下:</p><ol><li>父类中的静态成员变量 和 静态代码块</li><li>子类中的静态成员变量 和 静态代码块</li><li>父类中普通成员变量和代码块, 父类的构造方法</li><li>子类中普通成员变量和代码块</li></ol><p>总的来说, 即 <strong>静态&gt;非静态, 父类&gt;子类, 非构造方法&gt;构造方法</strong>, 同一类别(如:普通级)成员变量和代码块从前到后,需注意逻辑</p><h4 id="多态" tabindex="-1"><a class="header-anchor" href="#多态"><span>多态</span></a></h4><p>多态, 指同一个类的对象在不同情况下表现出不同行为和状态;</p><ul><li>子类继承父类, 子类直接使用父类的方法和字段(私有除外)</li><li>子类重写父类方法, 使子类调用该方法时表现出不同行为</li><li>子类对象赋给父类类型引用, 即通过父类类型引用可以调用子类重写的方法</li></ul><p>多态的目的; 是为了提高代码的灵活性和可扩展性, 使代码更容易维护和扩展; 比如多态实现动态绑定;</p><p>即多态就是, 一种行为具有不同的表现形式</p><p><strong>多态的前提条件</strong></p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul><h5 id="后期绑定" tabindex="-1"><a class="header-anchor" href="#后期绑定"><span>后期绑定</span></a></h5><p><strong>如何知道该调用父类方法还是子类方法?</strong></p><ul><li>在运行时, 根据对象的类型进行后期绑定</li><li>编译器 在编译阶段,不知道对象的类型, 但是Java的方法调用机制能找到正确的方法体</li></ul><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ul><li>封装; 指信息隐藏, 将数据和对数据的操作封装在一起, 构成不可分割的实体, 只对外暴露一些方法,而不暴露具体使用细节</li><li>继承; 子类继承父类, 子类可以使用父类非私有的属性和方法, 同时也可以在父类的基础上扩展, 主要目的时 复用代码</li><li>多态; 指同一个行为具有不同的表现形式或形态的能力</li></ul><h3 id="多态-1" tabindex="-1"><a class="header-anchor" href="#多态-1"><span>多态</span></a></h3><ul><li><a href="https://segmentfault.com/a/1190000022705651" target="_blank" rel="noopener noreferrer">理解Java中的多态机制,一篇文章帮你掌握<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li><li><a href="https://www.bilibili.com/video/BV1Rj411F7Z2/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0" target="_blank" rel="noopener noreferrer">向上转型和向下转型<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li><li><a href="https://gitee.com/code_to_attack/onJava8/blob/master/docs/book/09-Polymorphism.md" target="_blank" rel="noopener noreferrer">Java编程思想_第5版_中文<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h4 id="绑定" tabindex="-1"><a class="header-anchor" href="#绑定"><span>绑定</span></a></h4><h5 id="方法调用绑定" tabindex="-1"><a class="header-anchor" href="#方法调用绑定"><span>方法调用绑定</span></a></h5><p>将一个方法调用和一个方法主题关联起来称作<strong>绑定</strong>;</p><p>若绑定发生在程序运行前(由编译器和链接器实现), 叫做前期绑定</p><p>若发生在运行时,根据对象的类型进行绑定, 则称为后期绑定(也称为动态绑定或运行时绑定)</p><p>Java中除了static和final方法(private方法也是隐式的final)外, 其他所有方法都是后期绑定, 即通常情况下,不需要判断后期绑定是否会发生,即自动发生</p><p><strong>为什么将一个对象(方法)指明为final?</strong></p><ul><li>可以防止方法被重写</li><li>同时也有效的&quot;关闭了&quot;动态绑定, 即告诉编译器不需要进行动态绑定,可以让编译器为final方法生成更高效的代码, (大部分情况,不会提升程序整体性能,应该为了设计使用final,而不是性能)</li></ul><h3 id="继承-1" tabindex="-1"><a class="header-anchor" href="#继承-1"><span>继承</span></a></h3><ul><li><a href="https://www.bilibili.com/video/BV14o4y1h7ri/?spm_id_from=333.788&amp;vd_source=894a223b85ae44e61e16dcd1a7356db0" target="_blank" rel="noopener noreferrer">Java的作者为什么拒绝设计支持多继承关系？<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h2 id="抽象类和接口" tabindex="-1"><a class="header-anchor" href="#抽象类和接口"><span>抽象类和接口</span></a></h2><h3 id="参考资料-1" tabindex="-1"><a class="header-anchor" href="#参考资料-1"><span>参考资料</span></a></h3><p>文档:</p><ul><li><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/13%20%e8%b0%88%e8%b0%88%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">谈谈接口和抽象类有什么区别？<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><p>书籍:</p><ul><li><a href="https://gitee.com/code_to_attack/onJava8/blob/master/docs/book/10-Interfaces.md#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener noreferrer">Java编程思想_第5版(第十章 接口)<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h3 id="接口和抽象类区别" tabindex="-1"><a class="header-anchor" href="#接口和抽象类区别"><span>接口和抽象类区别</span></a></h3><p><strong>经典回答:</strong></p><p>接口和抽象类都是Java面向对象设计的两个基本机制</p><p>接口是对行为的抽象,是抽象方法的集合,利用接口可以达到API定义和实现分离的目的;</p><ul><li>接口不能实例化</li><li>不能包含任何非常量成员, 任何field都是隐含<code>public static final</code>的意义</li><li>也没有非静态方法实现, 也就是接口中的方法, 要么为抽象方法,要么为静态方法</li><li>Java标准类库中,定义了非常多的接口,比如<code>java.util.List</code></li></ul><p>抽象类是不能实例化的类, 用abstract关键字修饰class, 其主要目的是<strong>代码重用</strong>,除了不能实例化,形式上和一般Java类并没有太大区别;</p><ul><li>可以有一个或多个抽象方法, 也可以没有抽象方法</li><li><strong>抽象类大多用于抽取相关 Java 类的共用方法实现 或者是共同成员变量, 然后通过继承的方式达到代码复用的目的</strong></li><li>Java标准类库中,collection框架,很多通用部分被抽取成为抽象类, 例如<code>java.util.AbstractList</code></li></ul><p>Java类实现<code>interface</code>使用<code>implements</code>关键词, 继承抽象类使用<code>extends</code>关键词</p><p><strong>考点分析:</strong> 是个非常高频的Java面向对象基础问题; 可以从不同角度全面地考察对基本机制的理解和掌握;比如:</p><ul><li>对于Java的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目</li><li>在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在review代码的时候看出明显的不利于未来维护的设计</li><li>掌握Java语言特性演进。现在非常多的框架已经是基于Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的</li></ul><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口"><span>接口</span></a></h3><table><thead><tr><th>特性</th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>组合</td><td>新类可以组合多个接口</td><td>只能继承单一抽象类</td></tr><tr><td>状态</td><td>不能包含属性（除了静态属性，不支持对象状态）</td><td>可以包含属性，非抽象方法可能引用这些属性</td></tr><tr><td>默认方法 和 抽象方法</td><td>不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td><td>必须在子类中实现抽象方法</td></tr><tr><td>构造器</td><td>没有构造器</td><td>可以有构造器</td></tr><tr><td>可见性</td><td>隐式 public</td><td>可以是 protected 或友元</td></tr></tbody></table><p>组合接口时, 不同的接口中使用相同的方法名通常会造成代码可读性的混乱,尽量避免这种情况</p><h4 id="接口适配" tabindex="-1"><a class="header-anchor" href="#接口适配"><span>接口适配</span></a></h4><p>即相同的接口可以有多个实现, 比如一个方法可以接收接口作为参数, 该接口的实现和传递对象则取决于方法的使用者; 所以接口的常见用法,就是 策略设计模式 ;</p><p>编写一个方法执行某些操作, 并接受一个指定的接口作为参数, 即&quot;只要对象遵循接口,就可以调用方法&quot;, 使方法更灵活,通用,并更具可复用性</p><h4 id="接口和工厂方法模式" tabindex="-1"><a class="header-anchor" href="#接口和工厂方法模式"><span>接口和工厂方法模式</span></a></h4><blockquote><p>接口是多实现的途径，而生成符合某个接口的对象的典型方式是工厂方法设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现</p></blockquote><h2 id="方法重写和重载" tabindex="-1"><a class="header-anchor" href="#方法重写和重载"><span>方法重写和重载</span></a></h2><h3 id="参考资料-2" tabindex="-1"><a class="header-anchor" href="#参考资料-2"><span>参考资料</span></a></h3><p>文档:</p><ul><li><a href="https://segmentfault.com/a/1190000040879281" target="_blank" rel="noopener noreferrer">重载和重写的区别<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h3 id="重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#重载和重写的区别"><span>重载和重写的区别</span></a></h3><blockquote><p>面试题：重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分</p></blockquote><h4 id="重写" tabindex="-1"><a class="header-anchor" href="#重写"><span>重写</span></a></h4><p>重写是 子类对父类允许访问的方法的实现过程进行重新编写, 返回值和形参不能变, 即<strong>外壳不变,核心重写</strong></p><p><strong>方法的重写规则</strong></p><ol><li>参数列表与被重写方法的参数列表 必须完全相同</li><li>返回类型与被重写方法的返回类型可以不同, 但必须是被重写方法返回类型的派生类</li><li>访问权限不可以比被重写方法的访问权限更低</li><li>父类的方法 只能被子类重写</li><li>声明为final的方法不能被重写</li><li>声明为static的方法不能被重写, 但是能够被重新声明</li><li>子类和父类在同一个包下, 子类可以重写父类所有方法,除了声明为<code>private</code>和<code>final</code>的方法</li><li>子类和父类不在同一个包下, 子类只能重写父类 声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法</li><li>重写的方法，m能够抛出新的任何非强制异常, 但是抛出的新的强制性异常,只能是被重写方法的强制性异常的子异常</li><li>构造方法不能重写</li><li>如果不继承一个类, 则不能重写该类的方法</li></ol><h4 id="重载" tabindex="-1"><a class="header-anchor" href="#重载"><span>重载</span></a></h4><p>重载 是在一个类中, 方法名字相同,而参数不同, 返回类型可以相同也可以不同</p><p><strong>每个重载的方法, 都必须有一个独一无二的参数类型列表</strong></p><p>方法重载的好处, 就是让类以统一的方式处理不同类型的一种手段, 调用方法时通过传递给方法的不同个数和类型的参数来决定具体使用哪个方法, 这就是多态性</p><p>特点: 发生在本类, 方法名相同, 参数列表不同, 与返回值无关, 之和方法名,参数的类型相关</p><p><strong>重载规则</strong></p><ol><li>被重载的方法必须改变参数列表(参数个数或类型不一样)</li><li>被重载的方法可以改变返回类型</li><li>被重载的方法可以改变访问修饰符</li><li>被重载的方法可以声明新的 或 更广的 检查异常</li><li>方法可以在 同一个类中 或 一个子类中 被重载</li><li>无法以 返回值类型作为重载函数的区分标准</li></ol><h4 id="问题解答" tabindex="-1"><a class="header-anchor" href="#问题解答"><span>问题解答</span></a></h4><p><strong>区别:</strong></p><ol><li>方法重载是指在一个类中定义了多个方法名相同, 但是参数列表不同,称为方法重载</li><li>方法重写,是发生在子类继承父类, 子类中存在方法与父类中的方法的名字相同,参数列表相同,返回值也相同的, 称为重写</li><li>方法重载是一个类的多态性的表现, 而方法重写是子类与父类的一种多态性表现</li></ol><p>此外, 重载无法根据返回值类型进行区分</p><p><strong>为什么不能仅根据返回类型来区分重载呢?</strong> 因为 在调用目标方法时, 无法指定返回值类型信息, 此时编译器不知道需要调用哪个函数</p><blockquote><p>函数的返回值只是作为函数运行之后的一个“状态”他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”</p></blockquote><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类"><span>内部类</span></a></h2><h3 id="参考资料-3" tabindex="-1"><a class="header-anchor" href="#参考资料-3"><span>参考资料</span></a></h3><p>书籍:</p><ul><li><a href="https://gitee.com/code_to_attack/onJava8/blob/master/docs/book/11-Inner-Classes.md" target="_blank" rel="noopener noreferrer">Java编程思想_第5版(第十一章内部类)<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></li></ul><h3 id="内部类-1" tabindex="-1"><a class="header-anchor" href="#内部类-1"><span>内部类</span></a></h3><blockquote><p>一个类定义在另一个类中, 叫做内部类</p></blockquote><p><strong>内部类自动拥有外部类所有成员的访问权, 如何做到呢?</strong></p><p>当外部类创建一个内部类对象时, 内部类对象 会秘密捕获一个指向那个外部类对象的引用, 在访问外部类成员时, 使用捕获的引用来选择外部类的成员</p><h4 id="嵌套类" tabindex="-1"><a class="header-anchor" href="#嵌套类"><span>嵌套类</span></a></h4><p>普通的内部类对象隐式的保存了一个引用, 指向创建它的外部类对象, 当内部类是static时, 就不是这样了,此时为嵌套类, 意味着:</p><ol><li>要创建嵌套类的对象, 并不需要其外部类的对象</li><li>不能从嵌套类的对象中访问非静态的外部类对象</li></ol><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西</p></div><h4 id="为什么需要内部类" tabindex="-1"><a class="header-anchor" href="#为什么需要内部类"><span>为什么需要内部类</span></a></h4><p>一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口;</p><blockquote><p>内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外部类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这样做。”那么内部类实现一个接口与外部类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：</p><p><strong>每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响</strong></p></blockquote><p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，<strong>内部类使得多重继承的解决方案变得完整</strong>。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类</p><p>如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p><ol><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。</li><li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。 稍后就会展示一个这样的例子。</li><li>创建内部类对象的时刻并不依赖于外部类对象的创建</li><li>内部类并没有令人迷惑的&quot;is-a”关系，它就是一个独立的实体。</li></ol><h5 id="闭包与回调" tabindex="-1"><a class="header-anchor" href="#闭包与回调"><span>闭包与回调</span></a></h5><blockquote><p>闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域.</p></blockquote><p>通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括 private 成员</p><h6 id="内部类与控制层框架" tabindex="-1"><a class="header-anchor" href="#内部类与控制层框架"><span>内部类与控制层框架</span></a></h6><blockquote><p>应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题</p><p>控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作 事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统</p></blockquote><p>内部类允许：</p><ol><li>控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的 action()。</li><li>内部类能够很容易地访问外部类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。</li></ol><h2 id="重点掌握检测" tabindex="-1"><a class="header-anchor" href="#重点掌握检测"><span>重点掌握检测</span></a></h2><p><a href="https://b1lnfhp38ze.feishu.cn/wiki/L5auwbQzRiQrdLk4tCLcvFywnaf" target="_blank" rel="noopener noreferrer">面向对象特性<span class="vpi-external-link external-icon" data-v-22577cb5></span></a></p></div><!----></div><footer class="page-footer" data-v-4ad3b558 data-v-6f3122aa><!----><div class="contributors" data-v-6f3122aa><span class="contributors-label" data-v-6f3122aa>贡献者: </span><span class="contributors-info" data-v-6f3122aa><!--[--><!--[--><span class="contributor" title="email: 18570354653@163.com" data-v-6f3122aa>YTAZWC</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-6f3122aa><div class="pager" data-v-6f3122aa><a class="auto-link link pager-link prev" href="/java/" data-v-6f3122aa data-v-9dcd60c1><!--[--><span class="desc" data-v-6f3122aa>上一页</span><span class="title" data-v-6f3122aa>Java重点学习</span><!--]--><!----></a></div><div class="pager" data-v-6f3122aa><!----></div></nav></footer><!----><!--]--></div></div></div></div><button style="display:none;" type="button" class="back-to-top-button" aria-label="back to top" data-v-a5c639d0 data-v-cd9038ab><span class="percent" data-v-cd9038ab>0%</span><span class="show icon vpi-back-to-top" data-v-cd9038ab></span><svg aria-hidden="true" data-v-cd9038ab><circle cx="50%" cy="50%" style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-cd9038ab></circle></svg></button><footer class="plume-footer has-sidebar" data-v-a5c639d0 data-v-c7f71376><div class="container" data-v-c7f71376><p class="message" data-v-c7f71376>Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://github.com/pengzhanbo/vuepress-theme-plume">vuepress-theme-plume</a></p><!----></div></footer><!--]--></div><!--]--></div><!--[--><!--]--><!--]--></div><script type="module" src="/blogs/assets/app-5Dm3QmMW.js" defer></script></body></html>